吕泽
lvze@tedu.cn

mysql 
网络编程  3 
进程线程  4.5
网络 + 进程线程  1.5
MongoDB  4
regex   1.5
项目编程  2.5

难点 ： IO多路复用
        项目编写
	多任务编程理解

网络编程


网络目的 ： 数据传输

ISO(国际标准化组织)

OSI七层模型  ----》 网络通信的标准化流程

应用层 ： 提供用户服务， 具体的内容由特定的程序规定
表示层 ： 提供数据的加密和压缩优化
会话层 ： 确定建立应用连接，选择传输服务
传输层 ： 提供数据传输服务，进行流量控制
网络层 ： 路由选择，网络互联
链路层 ： 提供链路交换，具体消息的发送
物理层 ： 物理硬件，接口，网卡的规定

四层模型

应用层
传输层
网络层
物理链路层

五层模型（TCP/IP模型）

应用层  （应用层  表示层  会话层）
传输层
网络层
链路层
物理层

OSI模型优点 ： 将功能分开，降低网络传输中的耦合度。使开发流程更加清晰，每部分各司其职

高内聚 ： 每个模块功能尽量单一，不会多个功能掺杂
低耦合 ： 尽量降低每个模块之间的关联性

要求 ： 能够顺序说出七层模型 五层模型
        知道每一层干什么事情
	理解消息传输流程

网络协议：在网络通信中协议各方必须遵守的规定。如建立什么连接，消息结构如何解析等


应用层 ： TFTP   HTTP  DNS  SMTP 
传输层 ： TCP   UDP 
网络层 ：  IP 
物理层 ：  IEEE

网络相关概念

网络主机 ： 在网络上确定一台主机

本地使用 ： 'localhost'    127.0.0.1

网络地址 ： '0.0.0.0'   '172.60.50.54' (本机网络IP)

查看本机IP地址：ifconfig    (linux)
                ipconfig     (windows)

ipython3   进入交互模式

通过计算机名获取匹配的IP
In [5]: socket.gethostbyname('tedu')
Out[5]: '127.0.1.1'

In [6]: socket.gethostbyname('localhost')
Out[6]: '127.0.0.1'

获取本机的计算机名
In [7]: socket.gethostname()
Out[7]: 'tedu'


IP地址

网络上确定一台主机的地址

IPv4： 点分十进制  比如 192.168.1.3   0--255 

IPv6   128位


网络连接测试
ping 172.60.50.180

特殊IP
127.0.0.1  本地测试IP
0.0.0.0    自动使用本地可用网卡IP
192.168.1.0  代表当前网段
192.168.1.1  通常为网关地址
192.168.1.255  广播地址


In [2]: socket.gethostbyaddr('www.baidu.com')
Out[2]: ('127.0.0.1', [], ['119.75.213.61'])
          主机       别名   IP地址

IP地址转换为十六进制表达
In [4]: socket.inet_aton('192.168.1.2')
Out[4]: b'\xc0\xa8\x01\x02'

In [5]: socket.inet_ntoa( b'\xc0\xa8\x01\x02')
Out[5]: '192.168.1.2'


域名：网络服务器地址在网络上的名称

端口号： 端口号是地址的一部分，在一个系统中每个网络         应用监听不同的端口，以获取对应端口传递的信息

取值范围 ： 1----65535
1-255  一些通用端口 （众所周知的程序占用）
256 --1023   系统端口
1024 --  65535  自用端口  >10000

获取应用程序端口
In [2]: socket.getservbyname('mysql')
Out[2]: 3306


传输层服务

面向连接的传输服务 ---》 tcp协议

传输特征：

可靠的数据传输
可靠性 ： 数据在传输中，无失序 无差错  无丢失 无重复 

在数据传输前和传输结束后需要建立连接和断开连接

三次握手 ： 在面向连接的传输服务中建立连接的过程

1. 客户端向服务器发送连接请求
2. 服务器接受到请求进行确认，返回确认报文
3. 客户端收到服务器回复最终确认连接

四次挥手 ： 在面向连接的传输服务站断开连接的过程

1. 主动方发送报文，告知被动方要断开连接
2. 被动方回复报文，表示已经接收到请求，准备断开
3. 被动方再次发送报文，表示准备处理就绪，可以断开
4. 主动发发送确认报文，断开连接

应用情况 ： 适用于传输较大的内容或文件，网络良好，需             要保证传输可靠性的情况
e.g.  聊天信息   文件的上传下载， 邮件处理
      网页获取

面向无连接的传输服务 ---》 udp协议

传输特点：
不保证传输的可靠性
没有连接和断开的过程
数据的首发比较自由

适用情况 ： 网络情况可能产生丢包，对传输可靠性要求低

e.g.  ： 网络视频，  群聊，广播等

要求：
1. 理解三次握手和四次挥手，能够描述过程
2. 知道tcp传输和udp传输的区别


socket 套接字编程

目的 ： 通过编程语言提供的套接字编程接口，可以更简单的完成基于tcp和udp的编程

套接字 ： 完成上述目标的一种编程手段

套接字类别 

流式套接字（SOCK_STREAM）：传输层基于tcp的协议通信
       面向连接可靠的传输   tcp的传输   流式套接字

数据报套接字（SOCK_DGRAM）： 传输层基于udp协议传输
   面向无连接不可靠的传输   udp的传输   数据报套接字

底层套接字 （SOCK_RAM）: 访问底层协议套接字


TCP的服务端

import socket

1. 创建套接字

socket.socket(sock_family = AF_INET,
              sock_type = SOCK_STREAM,
	      proto = 0)
功能 ： 创建套接字
参数 ： sock_family  地址族类型 AF_INET ipv4网络通信
        sock_type   套接字类型  SOCK_STREAM 流式
	                        SOCK_DGRAM  数据报
	proto  通常为0  选定子协议类型
返回值 ： 返回套接字对象

2. 绑定地址

sockfd.bind(addr)
功能 ： 绑定地址
参数 ： addr  ---》 元组 （ip,port） ('0.0.0.0',1234)

3. 设置监听套接字

sockfd.listen(n)
功能： 将套接字设置为监听套接字，创建监听队列
参数： 监听队列大小

* 一个监听套接字可以连接多个客户端

4. 等待接受客户端连接

connfd,addr = sockfd.accept()
功能 ： 阻塞等待处理客户端连接
返回值 ： connfd  新的套接字，用于和客户端通信
          addr  连接的客户端的地址 （ip,port） 


* 阻塞函数 ： 当程序运行到阻塞函数位置，如果某种条件没有达成则暂停程序运行，知道条件达成结束阻塞

5. 消息的收发

data = connfd.recv(buffersize)
功能 ： 接受消息
参数 ： 一次接受消息的大小  字节
返回值 ： 返回接受到的内容

n = connfd.send(data)
功能 ： 发送消息
参数 ： 要发送的内容 （bytes格式）
返回值 ： 返回实际发送的字节数

6. 关闭套接字

sockfd.close()

* telnet  ip   port

客户端

1. 创建套接字 （和服务端套接字类型相同）
2. 发起连接

connect（addr）
功能 ： 向服务端发起连接
参数 ： 服务端地址   元组

3. 消息收发 
4. 关闭套接字

作业 ： 
1. 将要求内容整理话术回答
2. 将tcp交互程序改写为可以连续的收发消息
===========================================================================
前情回顾

1. osi七层模型 ---》 四层  五层
2. 三次握手四次挥手
3. tcp和udp区别

网络概念 ： 主机   端口    ip    协议
        服务端  localhost / 127.0.0.1
  客户端  只是在本机启动客户端 用127.0.0.1访问
  
  服务端  0.0.0.0
  客户端  可以在本机用127.0.0.1 、172.60.50.181
          访问
    局域网内 用 172.60.50.181 访问
  
  服务端  172.60.50.181
  客户端  局域网内用  172.60.50.181访问

套接字 socket

流式套接字  --》 tcp   可靠地  有连接
数据报套接字  --》 udp  不可靠  无连接

tcp 服务端
socket  --》 bind  --》 listen --》 accept  --》 recv/send --> close

******************************************************

recv()  特征
* 如何连接的另一端断开连接，则recv立即返回空子串
* recv是从接受缓冲区取出内容，当缓冲区为空则阻塞
* recv如果一次接受不完缓冲区内容，下次会继续接收

send() 特征
* 如果发送的另外一段不存在则会产生Pipe Broken
* recv是向发送缓冲区发送内容，当缓冲区为满阻塞



网络的收发缓冲区

在内存中开辟的区域，用作发送和接受的缓冲

* 协调数据收发（接受和处理）速度
* 减少和磁盘的交互


sendall(data)
功能 ： tcp套接字发送消息
参数 ： 同send
返回值：如果发送成功返回None


tcp粘包

产生原因： 
* tcp传输以字节流的方式发送消息，消息之间没有边界
* 发送比接受的速度快

影响 ： 对每次发送的内容是一个独立的意思需要单独识别

如何处理:
1. 每次发送后加一个结尾标志
2. 发送一个数据结构
3. 每次发送有一个间隔


基于UDP的服务端编程

1. 创建套接字

sockfd = socket(AF_INET,SOCK_DGRAM)

2. 绑定地址
sockfd.bind()

3. 消息收发

data,addr = sockfd.recvfrom(buffersize)
功能： 接受UDP消息
参数： 每次最多接受消息的大小  字节
返回值：data 接收到的内容
        addr 消息发送方的地址

* recvfrom每次接收一个报文，如果没有接收完全则丢弃没有收到的内容

sockfd.sendto(data,addr)
功能： UDP消息发送
参数： data  要发送的内容   bytes
       addr  目标地址
返回：发送字节数

4. 关闭套接字
sockfd.close()


cookie ： 

import  sys 
sys.argv
作用 ： 获取从命令行得到的参数内容
sys.argv[0] 是命令本身


tcp流式套接字和udp数据报套接字区别
1. 流式套接字采用字节流方式进行传输，而数据报套接字    使用数据报形式传输数据
2. tcp套接字会产生粘包，udp不会
3. tcp编程可以保证消息的完整性，udp则不能保证
4. tcp需要listen  accept，udp不用
5. tcp消息的发送接收使用recv  send  sendall，udp使用    recvfrom，sendto

要求 ： 能够说出tcp，udp协议的区别和编程实现上的差异


soccket模块和套接字属性
（s为套接字）

套接字属性
s.type :  表示套接字类型
s.family : 地址类型

套接字属性方法 
s.fileno()
功能 ： 获取套接字的文件描述符
文件描述符 ： 每一个IO事件操作系统都会分配一个不同的正整数与之匹配，该整数即为此IO的文件描述符

sys.stdin   0
sys.stdout  1
sys.stderr  2

s.getsockname()
功能 ： 获取套接字绑定的地址

s.getpeername()
功能 ： 获取连接套接字客户端的地址

s.setsockopt(level,optname,value)
功能 ： 设置套接字选项
参数 ： level   设置选项的类型   SOL_SOCKET
        optname   子类选项
  value    要设置的值

s.getsockopt(level,optname)
功能 ： 获取套接字选项值
参数 ： level   要获取选项的类型   SOL_SOCKET
        optname   子类选项
返回值 ： 获取的值



udp套接字应用 ---》 广播（broadcast）

一点发送多点接收

目标地址 ： 广播地址  172.60.50.255

cookie

In [3]: s = "{} is a {}".format('Tom','boy')

In [4]: s
Out[4]: 'Tom is a boy'

In [5]: s = "{1} is a {0}".format('Tom','boy')

In [6]: s
Out[6]: 'boy is a Tom'


tcp应用 ---》 http传输

http协议 ---》 超文本传输协议

用途 ： 网站中浏览器获取网页的过程

        编写基于http协议的数据传输

特点 ： 
1. 应用层协议，传输层使用tcp服务
2. 简单，灵活，可以使用多种编程语言操作
3. 无状态的协议，即不记录用户的输入内容
4. http1.1  ---> http2.0  技术成熟度和稳定性

http请求（request）

请求格式：

请求行   具体的请求类别和请求内容

 GET            /            HTTP/1.1
请求类别     请求内容        协议版本

请求类别 ： GET   获取网络资源
            POST  提交一定的附加数据，得到返回结果
      HEAD   获取响应头
            PUT    更新服务器资源
      DELETE  删除服务器资源
      CONNECT  
      TRACE   用于测试
      OPTIONS  获取服务器性能信息

请求头  ： 对请求的具体描述

Accept:text/html

* 每一个键值对占一行，描述了一个特定信息

空行
请求体 ： 具体的参数或者提交的内容

get参数或者post提交的内容


http响应 （response）

响应格式：

响应行 ： 反馈具体的响应情况

HTTP/1.1     200        OK
协议版本   响应码    附加信息

响应码 ：   1xx  提示信息，表示请求已经接受
            2xx  响应成功
      3xx  响应需要重定向
      4xx  客户端错误
      5xx  服务端错误
常见响应码
200    成功
404    请求内容不存在
401    没有访问权限
500    服务器发生未知错误
503    服务器暂时无法执行
    

响应头 ： 对响应内容的具体描述

Content-Encoding: gzip
Content-Type: text/html

空行
响应体 ： 将客户端请求内容进行返回

要求 ： 知道http作用
        掌握http协议 请求和响应的格式以及每一部分做什么
  掌握http协议中请求的基本类型和作用
  知道http协议响应码的类型和表达含义
  了解通过http协议请求网页的流程

作业：编写一个程序，完成一个文本文件（图片）在服务        端和客户端之间的传输 要求使用tcp套接字




====================================================================================================================
前情回顾

tcp套接字
1. 网络缓冲区
2. 粘包

udp 套接字
服务端  socket（AF_INET,SOCK_DGRAM）
        bind（）
  recvfrom()   sendto()
客户端  socket   recvfrom   sendto

tcp编程和udp编程的区别

套接字属性
fileno()   getpeername()   setsockopt()

广播 ： 一端发送多端接受  ---》udp

HTTP协议

请求类型 ： GET  POST   PUT   HEAD  DELETE
    格式 ：    GET   /   HTTP/1.1

响应类型 ： 2xx  4xx  5xx
    格式 ：    HTTP/1.1   200  OK
******************************************************
tcp应用之 httpserver

* 接收http请求
* 查看http请求
* 返回一个网页给客户端

IO  input  output

在内存中存在数据交换的操作可以认为是IO操作(输入输出）
e.g. 
内存和磁盘进行数据交换： 文件的读写  数据库更新
内存和终端数据交换 ： input   print  
                      sys.stdin sys.stdout  sys.stderr
内存和网络数据的交换： 网络连接  recv  send  recvfrom

IO密集型程序 ： 程序执行中有大量的IO操作，而较少的cpu运算操作。消耗cpu较少，IO运行时间长

CPU(计算)密集型程序：程序中存在大量的cpu运算，IO操作相对较少，消耗cpu大。

IO分类

阻塞IO   非阻塞IO    IO多路复用  事件驱动IO  异步IO


阻塞IO ：  程序运行中遇到IO条件没有达成或者传输过从较慢的情况会出现阻塞状态

* 阻塞IO是 IO最简单的逻辑情形，也是默认状态
* 阻塞IO是效率很低的IO形态

阻塞情况 ：
* 因为某种IO条件没有达到形成阻塞
 e.g.   accept  recv   recvfrom   input

* 处理IO事件的时候耗时较长形成阻塞
 e.g.  文件读写过程， 网络数据发送过程


非阻塞IO ： 在程序运行中遇到IO的情形不让其产生阻塞

实现手段： 改变IO事件的属性，使其变为非阻塞

* 通常会和循环一起使用，尽心条件的循环监控

s.setblocking(False)
功能 ： 将套接字设置为非阻塞
参数 ： 默认为阻塞状态 设置为False则为非阻塞


超时检测

将原本阻塞的函数，设置一个阻塞的最长时间。在时间内如果仍然阻塞则不再等待

s.settimeout(sec)
功能 ： 设置套接字的超时时间
参数 ： 时间 （秒）


IO多路复用

定义 ：通过一个监测，可以同时监控多个IO事件的行为。当哪个IO事件可以执行，即让这个IO事件发生。

IO事件就绪: IO事件即将发生的一个临界状态

* 在程序中存在的IO事件中选择要监测的
* 创建监测，将监测的IO事件注册
* 等待监测的IO时间发生，判断是什么IO事件
* 处理相应的IO

import  select

select  ---》 windows   linux   unix
poll ---》 linux  unix
epoll ---》 linux   unix

rs, ws, xs = select(rlist, wlist, xlist[, timeout])
功能 ： 监控IO事件，阻塞等待监控的IO时间发生
参数 ： rlist   列表  存放我们需要等待处理的IO 
        wlist   列表  存放我们想主动处理的IO
  xlist   列表  存放出错希望去处理的IO
  timeout  超时检测

返回值:  rs   列表  rlist中准备就绪的IO
         ws   列表  wlist中准备就绪的IO
   xs   列表  xlist中准备就绪的IO

* 在处理IO时不要形成死循环，让一个客户端单独占有服务端
* IO多路复兴形成一种可以同时处理多个IO的效果，效率较高


位运算
按照二进制位进行运算操作

& 按位与    | 按位或     ^ 按位异或 

<< 左移       >>  右移 

11    1011
14    1110

&     1010   一0则0
|     1111   一1则1  
^     0101   相同0不同1

11 << 2  ===> 44   右侧补0
14 >> 2  ===> 3    挤掉右侧的数字

使用 ：  1. 在做底层硬件时操作寄存器
         2. 做标志位的过滤

poll方法实现IO多路复用

1. 创建poll对象
p = select.poll()

2. 注册关注的IO
p.register(s,POLLIN | POLLERR)
p.unregister(s)   取消IO关注

事件类别
POLLIN   POLLOUT   POLLERR   POLLHUP   POLLPRI   
rlist    wlist     xlist     断开      紧急处理

3. 监控IO 
events = p.poll()
功能个： 监控关注的IO事件
返回值： 返回发生的IO事件
 events 是一个列表  [(fileno,evnet),(),()....]
 每个就绪IO对应列表中一个元组：（描述符，就绪事件）

IO地图 ： {s.fileno():s}

4. 处理IO事件

作业 ： 1. 熟练 select server 代码
        2. 了解 IO多路复用原理机制
  3. 写一个select服务端，同时关注客户端连接，客户端发送和终端输入。将客户端发送和终端输入的内容全都写入到一个文件中。

  sys.stdin






================================================================================================================================================
前情回顾
1. httpserver （http协议 + tcp套接字）
* 接收浏览器发来的请求 （HTTP请求）
* 查看请求内容
* 组织http响应子串
* 将内容发送给浏览器显示

2. IO 形态
    阻塞IO ： 默认IO 遇到条件阻塞或者传输阻塞会暂停程序运行。效率低

    非阻塞IO ：设置属性或者设置超时检测
                效率提升
    
    IO多路复用 
  目的 ： 在程序中有多个 IO事件的时候，同时监控，哪个能够执行就执行哪个，提高效率
  方法 ： select  poll
        设置要监控的io。阻塞等待IO事件发生。哪个发生就处理哪个IO
******************************************************
epoll
使用方法： 代码与poll基本一致
* 将生产的对象 改为  p = epoll() 
* 将关注事件类别名称改为epoll的关注事件类别

区别 :  
epoll 效率要高于select  和 poll
epoll 的触发机制更多--> EPOLLET(边缘触发)


本地套接字

cookie
linux下文件类型
b(块设备文件)   c（字符设备文件）     
d（目录）   -（普通文件）    l（链接文件）
s（套接字文件）    p（管道文件）

作用 ： 用于本地不同程序间进行数据传输

本地套接字传输流程

1. 创建套接字对象
sockfd = socket(AF_UNIX,SOCK_STREAM)
2. 绑定套接字文件，如果文件不存在则自动创建
sockfd.bind(file)
3. 监听 listen
4. 消息收发  recv  send

cookie

os.path.exists(file)
功能 ： 判断一个文件是否存在
参数 ： 文件
返回值 ： 存在 True   不存在 False

os.remove()
os.unlink()
功能 ： 删除一个文件
参数 ： 要删除的文件

网络基础总结

理论 ： 1. OSI七层模型  tcp/ip模型
        2. TCP 和  UDP的区别和特征
  3. 三次握手和四次挥手的过程和每一次作用
  4. 什么是IO多路复用，IO的基本形态
  5. 套接字的种类，套接字类型的区别

程序实践 ： 1. TCP套接字传输的基本模型
            2. UDP套接字传输基本模型
      3. IO多路复用select poll的使用
      4. HTTP协议基本原理的实现

多任务编程

意义： 充分利用计算机资源，同时运行多个任务，提高程序        整体的运行效率

定义 ： 通过程序利用计算机的多个核心达到同时执行多个         任务的目的。以此达到提升程序运行效率的目的

实施方案 ： 多进程编程   多线程编程

并行：多个计算机核心在同时处理多个任务，这时多个任务        之间是并行关系

并发：同时运行多个任务，内核在多个任务间不断切换，达       到多个任务都会被执行的处理效果。此时多个任务间        是并发关系

进程：程序在计算机中的一次执行过程

程序 ： 是一个可执行文件，是静态的，占有磁盘，不占计         算机的运行资源

进程 ： 进程是一个动态的过程，占有计算机资源，有一定         的生命周期

* 同一个程序不同的运行过程是不同的进程。因为分配的资源和生命周期都不相同

进程的创建流程
1. 用户启动一个程序或者调用接口发起进程创建
2. 操作系统接收用户请求分配计算机资源创建进程
3. 操作系统将一定状态的进程提供给用户使用
4. 用户利用操作系统提供的进程完成任务

进程相关概念

cpu时间片
如果一个进程占有cpu此时我们称为该进程占有cpu时间片。多个进程任务会轮流占有cpu时间片形成并发效果。

进程信息 （process）
PCB （进程控制块）：进程创建后会自动在内存生产一个空间存放进程信息。

进程信息 ： 进程的ID 进程占有内存的位置，创建时间，创建用户。。。

查看系统该进程信息 ：  ps  -aux

PID(process ID) : 在操作系统中每个进程都有唯一的PID值是由系统分配的。

进程特征

* 进程是操作系统分配资源的最小单元
* 每个进程拥有自己独立的运行空间 （虚拟内存空间）
* 进程之间运行相互独立互不影响

进程的状态

    三态
    * 就绪态 ： 进程具备执行条件，等待系统分配处理器             资源进入运行态
    * 运行态 ： 进程占有cpu处于运行状态

    * 等待态 ： 进程暂时不具备运行条件，需要阻塞等待

    五态 （三态基础上增加新建和终止）
    * 新建 ： 创建一个新的进程，获取系统资源的过程
    
    * 终止 ： 进程执行结束，释放资源的过程

   ps -aux  ---> STAT表示进程状态

   D  等待态 阻塞   不可中断等待态
   S  等待态 睡眠   可中断等待态
   T  等待态 暂停   暂停执行
   R  运行态（就绪态）
   Z  僵尸

   + 前台进程 （在终端运行） 
   <  有较高优先级的进程
   N  较低优先级的进程
   s  会话组
   l  有进程连接

进程的优先级

top 动态查看进程优先级

<  > 进行翻页  q退出

优先级的取值范围 ：   -20  ---  19    -20最高

nice ： 以指定的优先级运行一个程序

nice   -9   ./while.py  以9的优先级运行
sudo nice   --9   ./while.py  以-9优先级运行

cookie  
首行添加
#！/usr/bin/python3

修改程序权限添加可执行权限
chmod  775  while.py

可以直接指明路径执行
./while.py


父子进程

在系统中除了初始化进程每个进程都有一个父进程，可能有0个或多个子进程。由此形成进程间的父子关系。

便于进程管理，父进程发起创建子进程请求

查看进程树： pstree
查看父子进程PID ：  ps  -ajx

要求：
1.什么是进程，进程和程序的区别
2.了解进程的特征和基本概念
3.理解并发并行的区别
4.清楚进程的状态及转换


os.fork 创建进程

pid = os.fork()
功能 ： 创建进程
返回值：失败返回一个负数
        成功 ： 在原有进程中返回新进程的PID号
           在新进程中返回0

* 子进程会复制父进程全部内存空间包括代码段
* 子进程会从fork的下一句开始执行
* 父进程中fork返回值即为新创建子进程的PID号
* 父子进程不一定谁先执行，执行上互不干扰抢占时间片
* 使用if 语句结构使父子进程执行不同的代码几乎是fork   创建进程的固定结构
* 在子进程中对变量等其他内容的修改，不会影响父进程中   的内容
* 子进程虽然复制父进程内容，但是也有自己的特有属性特征。比如： PID号 PCB 内存区间等

获取进程PID

os.getpid()
功能：获取进程的PID号
返回值 ： 返回进程的PID号

os.getppid()
功能：获取父进程的PID号
返回值 ： 返回父进程的PID号

进程退出
os._exit(status)
功能 ： 退出一个进程
参数 ： 进程的退出状态  整数

sys.exit([status])
功能 ： 退出一个进程
参数 ： 默认为0
        如果传入一个整数则同 _exit()
  传入一个字符串。则在对出时打印该字符串

* sys.exit() 可以通过捕获 SystemExit异常阻止退出

作业 ： 进程fork理解
        熟悉进程的理论


============================================================================================
前情回顾

1. epoll 实现IO多路复用
2. 本地套接字：   AF_UNIX
    作用 ： 本地进程间的通信
3. 多任务编程
4. 多进程
    进程特征 : 最小的资源分配单元
               独立的空间
         互不影响的运行状态
    进程状态 ： 就绪态   运行态   等待态
5.  创建进程
    os.fork()

    os.getpid()   os.getppid()
    os._exit()    sys.exit()
****************************************************

孤儿进程 ： 当父进程先于子进程退出，此时子进程就会成             为孤儿进程。

* 孤儿进程会被系统指定进程收养，即系统进程会成为孤儿   进程新的父进程。系统进程会自动处理孤儿进程退出状态

僵尸进程 ： 子进程先于父进程退出，父进程没有处理子进             程的退出状态，此时子进程就会成为僵尸进程

* 僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统的内存资源，所以要尽量避免僵尸进程产生

如何避免僵尸进程产生
* 父进程先退出
* 父进程处理子进程退出状态

pid,status = os.wait()
功能 ： 在父进程中阻塞等待处理子进程的退出
返回值：pid  退出的那个子进程的PID号
        status  子进程的退出状态

获取原来退出状态
os.WEXITSTATUS(status)

pid,status = os.waitpid(pid,option)
功能 ： 在父进程中阻塞等待处理子进程的退出
参数 ： pid    -1  表示等待任意子进程退出
               >0  表示等待对应PID号的子进程退出
  option   0   表示阻塞等待
          WNOHANG  表示非阻塞
返回值：pid  退出的那个子进程的PID号
        status  子进程的退出状态

waitpid(-1,0)  ===> wait()

创建二级子进程

父进程创建子进程等待子进程退出
子进程创建下一级子进程，然后立即退出
二级子进程成为孤儿，处理具体工作


简单的群聊聊天室

功能 ： 类似于qq群聊
1. 进入聊天室需要输入姓名 姓名不能重复
2. 有人进入聊天室此时会向其他人发起通知
   xxx 进入了聊天室
3. 如果一个人发消息，则其他人都能收到
   xxx 说 ： xxxxxxx
4. 如果某个人退出聊天室其他人也会收到通知
   xxx 退出了聊天室
5. 服务端可以喊话 ：此时群里所有人都能收到服务端消息
   管理员 说：xxx

整体结构 ：分为几部分，如何封装，使用什么样的技术手段

服务端   客户端

在客户端和服务端每个功能封装为一个函数

技术方案：
转发 ： 一个客户端发送给服务器，服务器发送给其他人
套接字使用 ：udp 完成操作
用户存储： 字典 或者 列表  （可变类型，能够遍历提取）
           地址  用户名
发送和接受消息的控制：发送和接收使用多进程分离互不影响

注意事项：
1.注重封装
2.分段测试

代码编写流程

搭建通信  --》 创建多进程 ---》每个进程功能确定  --》 实现每一个功能模块

功能细节梳理

进入聊天室 
   客户端 ： 输入姓名 
             将信息发送给服务器  L name
       接受到服务端返回结果判断下一步执行什么
   
   服务端 ： 接受消息
             判断请求类型
       判断是否可以登录（姓名是否已经存在）
       返回给客户端是否登录（如果可以服务端会将姓名插入到存储结构）
       给所有人发送消息

聊天
      客户端 ： 发起聊天  C name msg
                接受服务器回复

      服务器 ： 接受消息 
                判断消息类型
    组织消息结构转发给其他客户端
  
退出聊天室
      客户端 ： 发送消息退出  Q  name
                接受回复
    退出程序
      服务端 ： 接受消息
                判断请求类型
    从用户结构删除对应用户
    告知所有人，xxx退出

multiprocessing 模块创建进程

1. 需要将要做的事情封装成函数
2. 使用multiprocessing提供的类Process创建进程对象
3. 通过进程对象和Process初始化进程进行进程的设置，绑    定函数
4. 启动进程，会自动执行绑定的函数
5. 完成进程的回收

创建进程对象
Process()
功能： 创建进程对象
参数： target ： 要绑定的函数
       name ： 给进程起的名称 （默认Process-1）
       args： 元组 用来给target函数位置传参
       kwargs : 字典  用来给target函数键值传参

p.start()
功能 ： 启动进程 自动运行terget绑定函数。此时进程被         创建

p.join([timeout])
功能： 阻塞等待子进程退出
参数： 超时时间

* 使用multiprocessing创建进程子进程同样复制父进程的全部内存空间，之后有自己独立的空间，执行上互不干扰
* 子进程也是有自己特有的PID等资源
* 如果不使用join回收可能会产生僵尸进程
* 使用multiprocessing创建子进程，一般父进程功能就是创建子进程回收子进程，所有事件交给子进程完成

作业 ： 1.梳理 聊天室代码
        2.对进程概念和创建过程巩固
  3.加深对http协议的理解
  4. 使用父子进程复制一个文件，分别复制文件的上半部分和下半部分到一个新的文件中。以字节区分


======================================================================================================================
前情回顾

1.孤儿进程  僵尸进程
2.聊天室
3.multiprocessing
  Process   start   join
****************************************************

Process（target,name,args,kwargs）

name : 给进程起名字
       默认为Process-1 Process-2.....
       p.name 可以获取进程名称

args : 以元组的形式给target函数传参

kwargs ： 以字典的形式给对应键的形参传参

进程对象的其他属性方法

p.name  p.start()  p.join() 

p.pid : 创建的新的进程的PID号
p.is_alive()  判断进程是否处于alive状态

p.daemon  默认为False 如果设置为True 则主进程退出时子           进程也会结束

* daemon 属性设置要在start() 前
* 设置daemon为True 则一般不需要加join

cookie
获取文件大小
size = os.path.getsize("./timg.jpeg")

注意：
如果多个子进程拷贝同一个父进程中的对象，则多个子进程使用的是同一个对象（如文件对象，套接字，队列，管道。。。）
如果是在创建子进程后单独创建的对象，则多个子进程各不相同

创建自定义进程类

1. 编写类继承Process
2. 在自定义类中加载父类__init__以获取父类属性，同时可以自定义新的属性
3. 重写run方法，在调用start时自动执行该方法

进程的缺点

进程在创建和销毁的过程中消耗的资源相对较多

进程池技术

产生原因 ： 如果有大量的任务需要多进程完成，而任务周期又比较短且需要频繁创建。此时可能产生大量进程频繁创建销毁的情况，消耗计算机资源较大


使用方法 ：
1. 创建进程池，在池内放入适当数量的进程
2. 将事件封装函数，放入到进程池
3. 事件不断运行，知道所有放入进程池事件运行完成
4. 关闭进程池，回收进程

from multiprocessing import  Pool

Pool(processes)
功能：创建进程池对象
参数：进程数量
返回 ： 进程池对象

pool.apply_async(fun,args,kwds)
功能 ： 将事件放入进程池执行
参数： fun 要执行的事件函数
       args  以元组为fun传参
       kwds  以字典为fun传参
返回值 ： 返回一个事件对象 通过get()属性函数可以获取
           fun的返回值

pool.apply(fun,args,kwds)
功能 ： 将事件放入进程池执行
参数： fun 要执行的事件函数
       args  以元组为fun传参
       kwds  以字典为fun传参
   

pool.close()
功能: 关闭进程池，无法再加入事件

pool.join()
功能 ： 回收进程池

pool.map(func,iter)
功能 ： 将要执行的事件放入到进程池
参数 ： func 要执行的函数
        iter 迭代对象，给func传参
返回值 ： 返回 func的返回值列表


进程间通信（IPC）

由于进程间空间独立，资源无法共享，此时在进程间通信就需要专门的通信方法。

进程间通信方法 ： 管道  消息队列  共享内存  信号
                   信号量    套接字

管道通信

在内存中开辟一块空间，形成管道结构，多个进程使用同一个管道，即可通过对管道的读写操作进行通信

multiprocessing ---》 Pipe

fd1,fd2 = Pipe(duplex = True)
功能: 创建管道
参数：默认表示双向管道
      如果设置为False则为单向管道
返回值 ： 两个管道对象，分别表示管道的两端
          如果是双向管道则均可读写
    如果是单向管道则fd1只读 fd2只写

fd.recv()
功能:从管道读取信息
返回值 ：读取到的内容

* 当管道为空则阻塞

fd.send(data)
功能: 向管道写入内容
参数： 要写入的内容

* 管道满时会阻塞
* 可以写入几乎所有的python数据

消息队列

队列 ： 先进先出

在内存中开辟队列结构空间，对多个进程可见。多个进程操作同一个队列对象可以实现消息的存取工作。

创建队列
q = Queue(maxsize = 0)
功能 ： 创建队列对象
参数 ： maxsize ： 默认表示系统自动分配队列空间
        如果传入正整数则表示最多存放多少条消息
返回值 ： 队列对象

q.put(data,[block,timeout])
功能：向队列中存入消息
参数：data  存入的消息 （支持python数据类型）
      block  默认True 表示当队列满时阻塞
             设置为False 则为非阻塞
      timeout  超时时间 

data = q.get([block,timeout])
功能: 获取队列消息
参数：block  默认为True 表示队列空时阻塞
             设置为False则表示非阻塞
      timeout 超时时间
返回值 ： 返回获取到的消息

q.full()  判断队列是否为满
q.empty() 判断队列是否为空
q.qsize()  获取队列中消息数量
q.close()  关闭队列

共享内存

在内存中开辟一段空间，存储数据，对过个进程可见。每次写入共享内存中的内容都会覆盖之前的内容。对内存的读操作页不会改变内存中的内容

from multiprocessing Value，Array 

shm = Value(ctype,obj)
功能： 开辟共享内存空间
参数： ctype  字符串  要转变的c的类型
        obj  共享内存的初始数据
返回值 ： 返回共享内存对象

shm.value  表示共享内存中的值


shm = Array(ctype,obj)
功能 ： 开辟共享内存空间
参数 ： ctype ： 要转换的数据类型
        obj ： 要存入共享内存的数据
        
        * 列表、字符串 表示要存入的内容，要                   求类型相同
        * 整数   表示要开辟几个单元的空间
返回值 ： 返回共享内存对象 可迭代对象


           管道         消息队列       共享内存 

开辟空间   内存          内存           内存

读写方式   两端读写     先进先出    每次覆盖上次内容
           双向/单向                   

效率       一般         一般            较快

应用      多用于父子   应用灵活广泛   复杂，需要同步
          进程                         互斥操作


作业 ： 熟练进程间通信和进程池的使用
        复习类的使用


=======================================================================================================
前情回顾

1 进程对象 p
p.name  进程名
p.pid   新进程的PID
p.is_alive()  查看进程状态
p.daemon  

2 自定义进程类
继承Process   重写run

3 进程池   避免大量进程频繁的创建删除
           Pool() 创建进程池
     apply_async()  添加时间
     close()  关闭进程池
     join()  回收进程池
     map()
4. 进程间通信
   管道 --》 Pipe（）
   消息队列 --》 Queue（） ---》 q
                q.put   q.get  q.full  q.empty
    q.qsize  q.close
   共享内存 --》 Value   Array

***************************************************

信号 

一个进程向另外一个进程通过信号的方式传递某种讯息。接收方在接收到信号后作出相应的处理。

kill  -l   查看信号
kill  -sig   PID   向一个进程发送信号 

关于信号

信号名称 ： 系统定义，名字或者数字
信号含义 ： 系统定义，信号的作用
默认处理方法 ：当一个进程接收到信号是，默认产生的效果
               终止进程    暂停进程    忽略发生
        
E.G.  
SIGHUP   断开连接
SIGINT   ctrl-c
SIGQUIT  ctrl-\
SIGTSTP  ctrl-z
SIGKILL  终止进程且不能被处理
SIGSTOP  暂停进程且不能被处理
SIGALRM  时钟信号
SIGCHLD  子进程状态改变发送给父进程信息号

python信号处理

os.kill(pid,sig)
功能 ： 发送一个信号给某个进程
参数 ： pid  给哪个进程发送信号
        sig  要发送什么信号


signal.alarm(sec)
功能: 设置时钟信号  在一定时间后给自身发送SIGALRM信号
参数： sec  时间（秒）

* 一个进程中只能有一个时钟，后来的时候会覆盖前面的时间

程序的同步执行和异步执行
同步 ： 程序按照步骤一步一步执行，呈现一个先后性和顺         序性
异步 ： 程序在执行中利用内核功能帮助完成必要的辅助操         作，不影响应用层持续执行

signal.pause()
功能： 阻塞进程，等待一个信号

signal.signal(sig,handler)
功能 ： 处理信号
参数 ： sig  要处理的信号
        handler  信号处理方法
     可选值 ： SIG_DFL  表示使用默认方法处理
               SIG_IGN  表示忽略这个信号
         func   自定义函数
           自定义函数格式 ： def func(sig,frame)
           sig : 接收到的信号
           frame： 信号结构对象

* signal函数也是一个异步处理函数。只要执行了该函数，则进程任意时候接收到相应信号都会处理。
* signal 是不能处理 SIGKILL SIGSTOP的
* 父进程中可以用 signal(SIGCHLD,SIG_IGN)将子进程的退出交给系统处理
* 信号是一种异步的进程间通信方法


信号量

给定一定的数量，对多个进程可见，并且多个进程根据信号量多少确定不同的行为

sem = Semaphore(num)
功能 ： 创建信号量对象
参数 ： 信号量的初始值
返回 ： 信号量对象

sem.acquire()  将信号量数量减1   当数量为0则阻塞
sem.release()  将信号量数量加1 
sem.get_value()  获取当前信号量的值 


同步互斥机制

目的 ： 解决对共有资源产生的资源争夺

临界资源 ： 多个进程或者线程都能够操作的资源
临界区 ： 操作临界资源的代码段

同步 ： 同步是一种合作关系，为完成某个任务，多进程或         者多线程之间形成一种协调，按照约定执行，相互         告知，共同完成任务。

互斥 ： 互斥是一种制约关系，当一个进程或者线程进入临         界区操作资源时采用上锁的方式，阻止其他进程操         作。直到解锁后才会让出资源


Event 事件

from multiprocessing import  Event

创建事件对象
e = Event()

事件阻塞
e.wait([timeout])
功能 ： 使进程处于阻塞状态，直到事件对象被set

事件设置
e.set()
功能 : 让事件对象变为被设置状态

清除设置
e.clear()
功能 ： 使事件对象清除设置状态

事件判断 判断当前事件对象的状态
e.is_set() 



锁  Lock

multiprocessing --》 Lock

创建对象
lock = Lock()

lock.acquire()  上锁 
lock.release()  解锁

* 如果一个锁对象已经被上锁则再调用acquire会阻塞

with  lock:    上锁
    ....
    ....
               解锁
  
多线程

什么是线程 （thread）

线程也是一种多任务编程方式，可以使用计算机的多核资源。线程被称为轻量级的进程。

线程特征： 
* 一个进程可以包含多个线程
* 线程是计算机内核使用的最小单位
* 线程也是一个运行过程，也要消耗计算机资源
* 多个线程共享共用进程的资源
* 线程也有自己的特征属性，TID 指令集，线程栈
* 多个线程之间独立运行互不干扰
* 线程的创建删除消耗的资源要小于进程


threading 模块的使用

threading.Thread()
功能 : 创建线程对象
参数 ： target  线程函数
        name   线程名称 默认Thread-1 
  args  元组   给线程函数位置传参
  kwargs  字典  给线程函数键值传参
返回 ： 线程对象

t.start()  启动线程
t.join([timeout])  回收线程

线程对象属性
t.name 线程名称
t.setName()  设置线程名称
t.is_alive()  查看线程状态
threading.currentThread()  获取到当前线程对象

t.daemon 属性
默认情况下主线程结束不会影响分支线程执行
设置为True时主线程退出则分支线程也退出

设置 daemon值
t.setDaemon(True)
t.daemon = True

查看daemon值
t.isDaemon()


创建自己的线程类

步骤 ： 
1 继承 Thread
2 加载父类 __init__
3 重写run

作业 ： 
1. 复习网络编程 tcp  udp
2. 司机和售票员

* 创建父子进程分别表示司机和售票员
* 当售票员捕捉到SIGINT信号时，给司机发送SIGUSER1信号
  此时司机打印 "老司机开车了" 
  当售票员捕捉到SIGQUIT信号时，给司机发送SIGUSER2信号。此时司机打印 "车速有点快，系好安全带"
  当司机捕捉到SIGTSTP信号时，给售票员发送SIGUSER1信号。此时售票员打印 "到站了请下车"
* 到站后 售票员先下车（子进程先退出）然后司机下车



========================================================================================================================



前情回顾

信号 ：在进程间通过信号传递讯息
    os.kill(pid,sig)  发送信号
    signal.alarm(sec) 设置时钟
    signal.pause() 阻塞等待
    signal.signal(sig,handler)  处理信号
                      SIG_DFL
          SIG_IGN
          fun(sig,frame)

信号量  semaphore
acquire()  消耗一个信号量
release()  添加一个信号量
get_value() 获取信号量的值

同步互斥机制
Event
Lock

多线程编程
  threading 创建线程
  线程对象属性
  自定义线程
***************************************************

* 创建父子进程分别表示司机和售票员
* 当售票员捕捉到SIGINT信号时，给司机发送SIGUSER1信号
  此时司机打印 "老司机开车了" 
  当售票员捕捉到SIGQUIT信号时，给司机发送SIGUSER2信号。此时司机打印 "车速有点快，系好安全带"
  当司机捕捉到SIGTSTP信号时，给售票员发送SIGUSER1信号。此时售票员打印 "到站了请下车"
* 到站后 售票员先下车（子进程先退出）然后司机下车


线程通信
   通信方法 ： 多个线程共用进程空间，所以进程的全局变             量对进程内线程均可见。线程往往使用全局             变量进行通信
   注意事项 ： 线程间使用全局变量进行通信，全局变量为             共享资源，往往需要同步互斥机制

线程的同步互斥

线程Event

创建对象：
    e = threading.Event()

事件阻塞函数
    e.wait([timeout])  

设置事件
    e.set()
  
清除事件
    e.clear（）
  

线程锁  Lock

lock = threading.Lock()   创建锁对象
lock.acquire()  上锁
lock.release()  解锁 

with  lock    上锁

python线程的GIL问题 

GIL （全局解释器锁）

python ---》 支持线程操作 ---》IO的同步和互斥 --》 加锁 ----》 超级锁，给解释器加锁

后果 ： 一个解释器，同一时刻只解释一个线程，此时其他         线程需要等待。大大降低了python线程的执行效率

python  GIL问题解决方案
* 修改c解释器
* 尽量使用多进程进行并行操作
* python线程可以用在高延迟多阻塞的IO情形
* 不使用cpython     c#   java做解释器

效率测试

分别测试 多进程  多线程  单进程执行相同的IO操作和CPU
操作的时间

Line cpu: 8.15166711807251
Line IO: 6.841825246810913

Thread cpu 8.414522647857666
Thread IO 6.023292541503906

Process cpu 4.079084157943726
Process IO 3.2132551670074463

进程和线程的区别和联系
1.两者都是多任务编程的方式，都能够使用计算机的多核
2.进程的创建删除要比线程消耗更多的计算机资源
3.进程空间独立，数据安全性好，有专门的进程间通信方法
4.线程使用全局变量通信，更加简单，但是需要同步互斥操   作
5. 一个进程可以包含多个线程，线程共享进程的空间资源
6. 进程线程都独立执行，有自己的特有资源如属性，id，    命令集等

使用情况：
* 一个进程中并发任务比较多，比较简单，适合使用多线程
* 如果数据程序比较复杂，特别是可能多个任务通信比较多   的时候，要考虑到使用线程同步互斥的复杂性
* 多个任务存在明显差异，和功能分离的时候没有必要一定   写入到一个进程中
* 使用python考虑线程GIL问题

要求：
1. 进程线程的区别和关系
2. 进程间都信方式都用过哪些，有什么特点
3. 同步和互斥是怎么回事，你都用哪些方法实现了同步互    斥
4. 什么是僵尸进程，怎么处理的
5. python线程的效率怎么样？GIL是怎么处理的


服务器模型

硬件服务器 ： 主机   集群
厂商 ： IBM  HP  联想  浪潮

软件服务器 ：编写的服务端程序，依托硬件服务器运行。              提供给用户一定的功能服务

服务器种类

webserver ---》 网络的后端应用程序，提供数据处理和逻                 辑处理
httpserver ---> 接受http请求，返回http响应

邮箱服务器 ---》 处理邮件请求，进行邮件收发

文件服务器 --》提供文件的上传下载存储

功能实现 ： 网络连接，逻辑处理，数据运算，数据交互
            协议实现，网络数据传输。。。。

模型结构 :   C/S   客户端服务器模型
             B/S    浏览器服务器模型

服务器目标：处理速度更快，数据安全性更强，并发量更高

硬件 ： 更高的配置，更好的硬件搭配，更高的网络速度
        更多的主机，网络安全投入

软件 ： 占有更少的计算机资源，更稳定的运行效率，更流         畅的速度，更强大的算法，更合理的技术搭配


网络服务器基础

循环服务器 ： 单进程程序，循环接受客户请求，处理请求。处理完毕再接受下一个请求。

特点 ： 每次只能处理一个客户端请求
        如果客户端长期占有服务器则无法处理其他客户端请求。

优点 ： 实现简单，占用资源少
缺点 ： 无法同时处理多客户端，体验差
使用情况 ： 任务短暂，可以快速完成。udp比tcp更适合循             环

并发服务器 ： 能够同时处理多个客户端任务请求

    IO 并发  :  IO多路复用     协程 
      
      优点 ： 可以实现IO的并发操作，占用系统资源少
      缺点 ： 不能监控cpu密集的情况，并能有长期阻塞

    多进程/多线程并发：为每个客户端单独提供一个进程/                     线程处理客户端请求 

      优点 ： 客户端可以长期占有服务器
      缺点 ： 消耗计算机资源较多

多进程并发模型

使用fork完成并发

1. 创建套接字，绑定，监听
2. 等待接受客户端连接请求
3. 创建新的进程处理客户端请求
   父进程继续等待连接其他客户端
4. 客户端退出 对应子进程结束


tftp 文件服务器

项目功能 ： 

* 客户端有简单的页面命令提示
* 功能包含：
1. 查看服务器文件库中的文件列表（普通文件）
2. 可以下载其中的某个文件到本地
3. 可以上传客户端文件到服务器文件库

* 服务器需求 ：1. 允许多个客户端同时操作
               2.每个客户端可能回连续发送命令

技术分析：
1. tcp套接字更适合文件传输
2. 并发方案  ---》 fork 多进程并发
3. 对文件的读写操作
4. 获取文件列表 ----》 os.listdir() 
   粘包的处理

整体结构设计
1. 服务器功能封装在类中（上传，下载，查看列表）
2. 创建套接字，流程函数调用  main（）
3. 客户端负责发起请求，接受回复，展示
   服务端负责接受请求，逻辑处理

编程实现

1. 搭建整体结构，创建网络连接
2. 创建多进程和类的结构
3. 每个功能模块的实现

作业 ： 补充完整 tftpserver的基本框架
        尝试实现 get或者put功能


===================================================================================================================

前情回顾

线程
    线程通信 ---》 全局变量
    线程的同步互斥 --》 Event  Lock
    python  GIL问题  ---》 python线程效率低下

线程和进程  区别和联系

服务器模型 ： 循环模型
                  每次只能处理一个客户端的请求

              并发模型
                  IO并发 ： IO多路复用  协程
                  多进程、多线程并发
                      每当有一个客户端就创建一个新的进程或者线程
多进程并发

fork + tcp

文件服务器
*************************************************************
cookie

os.listdir(path)
功能 : 获取文件列表

os.path.isfile() : 判断一个 文件是否为普通文件
os.path.isdir() ： 判断一个文件是否为目录 

多线程并发

threading模块完成多线程并发

对比多进程并发
优势 ： 资源消耗少
缺点 ： 需要注意对共享资源的操作

实现步骤：
1. 创建套接字，绑定，监听
2. 接收客户端连接请求，创建新的线程
3. 主线程继续等待其他客户端连接，分支线程执行客户端具体请求
4. 处理完客户端请求后分支线程自然退出，关闭客户端套接字



socket并发集成模块

python2  SocketServer
python3  socketserver

功能 ： 通过模块提供的接口组合可以完成多进程/多线程  tcp/udp的         并发程序

StreamRequestHandler    处理tcp请求
DatagramRequestHandler  处理udp请求

ForkingMixIn   创建多进程
ThreadingMixIn  创建多线程
 
TCPServer  创建tcp  server
UDPServer  创建udp  server

ForkingTCPServer     ForkingMixIn  +  TCPServer 
ForkingUDPServer     ForkingMixIn  +  UDPServer 
ThreadingTCPServer   ThreadingMixIn  +  TCPServer 
ThreadingUDPServer   ThreadingMixIn  +  UDPServer 


基于多线程并发的HTTPServer

1. 接收浏览器http请求
2. 对请求进行一定的解析
3. 根据解析结果返回对应内容
4. 如果没有请求内容则返回404
5. 组织Response格式进行回发

升级：
* 使用多线程并发
* 增加了具体的请求解析和404情况
* 使用类进行代码封装
* 增加一定的数据获取功能

技术点 ： threading并发
          tcp socket 传输
          HTTP请求和响应格式







