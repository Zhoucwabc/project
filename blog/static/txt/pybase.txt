python应用领域：系统运维
		网络编程（搜索引擎，爬虫，服务器编程）
		科学计算
		人工智能，机器人
		web 开发
		云计算
		大数据及数据库编程
		教育
		游戏，图像处理
		其他

	优点：面向对象（Java，C++，Python，c#，Swift）
	      免费
	      可移植（Windows，Linux，Unix，IOS，安卓）
	      可混合编程（c / c++ / Java / .net）
	      简单易学易用
	      应用领域广泛
	      开源
	缺点：与C/C++相比，执行速度不够快
	      不能封闭源代码

Python官网
	http://www.python.org

python的版本
	python V2.7 （2020年结束维护）
	python V3.5 （当前教学）
	python V3.8 （最新）

python的运行：
	python的解释执行器的类型
		CPython     （C语言开发）
		Jython      （Java语言开发）
		IronPython  （.net开发）
		PyPy	    （Python语言开发）

第一个python程序
	编写：hello.py

	执行python程序
	$ python 文件路径名.py
	例：
	$ python3 绝对路径或相对路径


常用的文件后缀：
	.py              python语言后缀
	.c               C语言
	.cpp/.cc/.cxx	 c++语言后缀
	.java            Java语言后缀


在python交互模式下编写并执行代码
	进入交互模式：
		$ python3 <回车>
	退出交互模式：
		>>>quit（）<回车>
		>>>exit（）<回车>
		或输入：ctrl+d （输入文件结束符）

python的注释
	以#开头，直至行尾
	作用：让注释内容不参加解释执行

	sublime 注释快捷键 ctrl+/

python 程序的组成
	程序是由模块组成
	模块是由数据，函数，类等组成
	函数由语句组成
	语句由表达式组成

python 的核心数据类型
	数字（整形数int，浮点型数float，复数complex，布尔型bool）
	字符串 str，列表 list 等

整形数 int
	整数是不带有小数部分的数字

	整数的字面值表示方式
		十进制表示方式：
		如：
		10
		200
		-100
		八进制表示方式：
		如：
		0o177  （127）
		0o11   （9）
		十六进制表示方式：
		如：
		0x11	（17）
		0xFF	（255）
		0x1a2b
		二进制表示方式：
		如：
		0b111
		0b101

浮点型数 float
	浮点数是带有小数部分的数字（小数部分可以是0）
		小数表示法：
			如：
			3.14     3.1    3.0     3.    0.14    .14 
		科学计数法：
			格式：
			小数  e/E （正负号） 指数
			如：
			6.18E-1		（等同于0.618）    6.18*10（-1）次方
			2.9979e8	（等于299790000.0）

复数complex
	分为两部分：
		实部（real）
		虚部（image）
	虚部是以j或J结尾的数

	字面值：
		1j
		(2J)
		1+2J
		3-4j

布尔型数 bool
	用来表示真和假两张状态的数字
		True表示真（条件满足或成立）
		False表示假（条件不满足或不成立）
	说明：
		True的值为1
		False的值为0


内置对象
	空值None
		None是一个表示不存的特殊对象
	作用：
		用来占位
		变量解除绑定

表达式和运算符
表达式expression
	由一个数字 或 数字和运算符 等组成

	作用：
		通常让计算做一些事情并返回结果
	如：
		1 + 2

运算符：
	算术运算符：
		+	加法
		-	减法
		*	乘法
		/	除法
		//	地板除floordiv
		%	求余
		**	幂运算

	/ 除法
	  除法得到的数是浮点型数，不会丢弃小数部分
	  1 / 3  # 得   0.333333333333333333333
	  8 / 2  # 得   4.0

	// 地板除
	   除得结果去掉小数部分向下取整
	   如：
		7 / 3		 # 得 2.3333333333333333
		7 // 3		 # 得 2
		3.25 // 1.5	 # 得 2.0
	% 求余
	  如：
		7 % 3		 # 得 1
		3.25 % 1.5	 # 得 0.25

	** 幂运算
	   格式：
		x ** y
		意为 x的y次方
	   如：
	   4 ** 2		# 得 16
	   3 ** 4.0		# 得 81.0

运算符得优先级
	**
	*  /  //  %             （优先级相同时自左向右）
	+  -
	实例：
		1 + 3 * 3 ** 2 + 4 // 2
	
括号分组子表达式：
	（）内部的表达式先进行计算

混合类型自动升级
	1 + 2.14 返回类型为浮点型  3.14
	3 + 4.0  返回  7.0

基本输出函数 print
	格式：
	print（要打印的东西）
	多个数据用逗号分隔开


变量  variable
	什么是变量
		变量是关联一个对象的标识符
	
标识符的命名规则；
	必须为字母或下划线开头，后跟字母或下划线或数字
	不能使用python的关键字


	说明：
		python的变量名区分大小写
	合法的标识符（变量名）   举例：
		abc  a1b2  _abc  __Abcd  var
	不合法的标识符：
		1a2b	$ABC	+a	-b	#ABC	@ABC
	python关键字：
		True， False， None， is， del, if, elif ..等
		
赋值语句
	=
	语法：
		变量名 = 表达式
		或
		变量名1 = 变量名2 = 表达式
		或
		变量名1，变量名2 = 序列
	作用：1. 创建一个变量，此变量用来绑定数据对象
	      2. 修改一个变量的绑定关系，让其绑定另一个数据对象

	说明：
		当变量不存在时，创建该变量，同时将变量绑定在这个对象上
		当变量存在时，改变此变量绑定的对象
		一个变量只能绑定一个对象
		两个变量可以同时绑定同一个对象
	示例：
		pi = 3.1415926
		pi2 = pi	# pi变量和pi2变量同时绑定 3.1415926
		x = y = 100	# x变量和y变量同时绑定  100
		x，y = 100，200 # 序列赋值

python中的自动化内存管理
	a = 10000
	b = 20000
	a = a + b	# 释放10000这个对象，a重新绑定30000
	c = a		# c同时绑定在30000上

	a，b = b，a

del 语句：
	作用：
		用于删除变量，同时解除与对象的关联关系，如果可能能释放对象
	语法：
		del 变量名

	在交互模式下查看当前作用域的所有变量
	>>> help('__main__')
	退出键：q

	示例：
		a=10000		# 创建a变量，绑定10000
		print（a）	# 10000
		del a		# 删除了a变量，释放10000这个数据对象
		print（a）	# 出错

自动化内存管理和引用计数
	每个对象都会记录有几个变量绑定（引用）自身，当引用的数量为0时，则此对象将被销毁（释放内存资源），
	此种自动化内存管理的方式叫引用计数

	例：
	a = 10000
	b = a		# 两个变量同时绑定10000这个数据对象
	del a
	del b		# 此时会释放10000这个数据对象

is / is not 运算符
	作用：
		判断两个对象是否是同一个对象，当是同一对象时返回True，否则返回False

	说明：
		is not  返回值与 is 相反
	语法：
		x is y
		x is not y

id（obj）函数
	作用：
		返回一个对象在内存中的地址

小整数对象池
	CPython中，整数 -5 至 256 的数永远存在于小整数池中，不会释放且可重复使用

	示例：
		a = 100
		b = 100
		a is b		# True

复合赋值算术运算符
	运算符：
	y += x		等同于 y = y + x
	y -= x		等同于 y = y - x	
	y *= x		等同于 y = y * x
	y /= x		等同于 y = y / x
	y //= x		等同于 y = y // x
	y %= x		等同于 y = y % x
	y **= x		等同于 y = y ** x

	例：
		x = 100
		x *= 2		# x = 200
		x = 100
		x = x * 2	# x = 200


============================================================================

email : weimz@tedu.cn
魏


比较运算符
	运算符：
		<	小于
		<=	小于等于
		>	大于
		>=	大于等于
		==	等于
		!=	不等于
	语法：
		左表达式 < 右表达式
	说明：
		比较运算返回布尔类型的值
	例:
		20 < 100	# True
		300 >= 20	# True
		1 == 2		# False
		x = 70		
		y = 70
		x != y		#False
		0 <= x <= 100	#True

数值对象的构造（创建）函数
float(obj)
用字符串或数字转换为浮点数，如果不给出实参，则返回0.0
int(x=0,base=10)
用数字或字符串转换为整数，如果不给出实参则返回0
complex(r=0.0,i=0.0)	用数字创建一个复数
bool(x)	用x创建一个布尔值(True/False)

函数调用表达式
	函数名（传参列表）
	说明：
		函数调用时表达式，此表达式一定会返回一个对象的引用关系。
		如果不需要返回值时，通常返回None对象的引用关系

bool(obj)	返回假值的情况：
	None	空值
	False	假值
	0，0.0，0j	所有的数字零
	-----以下后面会讲-----
	''	空字符串
	[]	空列表
	{}	空字典
	()	空元组
	...

内建数值型函数
	abs（x）	取X的绝对值
	round(number,ndigits=0)	对数值进行'四舍五入'，ndigits是小数向右取整的位数，负数表示向左取整
	pow(x,y,z=None)	相当于 x ** y 或 x ** y % z

help()	函数查看帮助
	help(函数名或对象名)
	>>>help(abs)

语句 statements
	语句由一些表达式组成，通常一条语句可以独立执行来完成一部分事情并形成结果
		python建议一条语句写在一行内；
		多条语句写在一行内需要用分号（；）分开
	示例：
		print（“hello”）
		x = 100 + 200
		print(x)
		# 写在一行内为：
		print("hello"); x = 100 + 200; print(x)

显示换行；
	折行符 \ （读作反斜杠）
		折行符必须放在一行的末尾，来示意解释执行器下一行也是本行的语句
	
隐式折行
	所有的括号的内容换行，称为隐式换行
	括号包括()	[]	{}

基本输入函数 input
	作用：
		从标准输入设备上读取一个字符串（末尾的换行符会被删除）
	格式：
		input（‘提示字符串’）
	说明：
		返回输入的字符串（仅python3）
		提示字符串可以为空


基本输出函数 print
	作用：
		将一系列的值以字符形式输出到标准输出设备上，
		默认为终端
	格式：
		print(value, ... sep=' ', end='\n',
		file=sys.stdout, flush=False)
	选项的关键字参数：
		sep：两个值之间的分隔符，默认为一个空格' '
		end: 输出完毕后在末尾自动追加一个字符串，默认为换行符'\n'

if 语句：
	作用：
		让程序根据条件选择性的执行某条语句或某些语句
	语法：
		if 真值表达式1：
			语句块1
		elif 真值表达式2：
			语句块2
		elif 真值表达式3：
			语句块3
		...
		else：
			语句块
	说明：
		elif 可以有0个，1个，或多个
		else 可以有0个或1个

if 语句的真值表达式
	if 100:
	    print('真值')
	等同于：
	if bool(100):
	    print('真值')

	if语句真值表达式返回的对象要用bool（x）取值后再决定执行哪条语句

if 语句的嵌套
	if 语句本身是由多条子句组成的一条复合语句
	if 语句可以作为语句嵌套到另一个语句的内部

条件表达式：
	语法：
		表达式1 if 真值表达式 else 表达式2
	作用：
		根据真值表达式的取值（True/False）
		来决定执行表达式1或表达式2，并返回结果
pass 语句
	作用：
		通常用来填充语法空白
		pass又名空语句
	语法：
		pass

布尔运算
	运算符：
		not	and	or

布尔非操作	not
	语法：
		not x
	作用：
		对表达式x进行布尔取非. 如bool（x）
		为True则返回False，否则返回True
	示例：
		not True	# 返回False
		not False	# 返回True
		month = 10
		if not 1 <= month <=12:
			print('month 不在1~12之间')

布尔与操作	and
	语法：
		x and y
		注：x，y 代表表达式
	作用：
		优先返回假值对象
		当x的布尔值为False时，返回x，否则返回y
	示例：
		True and True	#True
		True and False	#False
		False and True	#False
		False and False	#False
		0 and 0.0	#0
		1.2 and 100	#100

布尔或操作	or
	语法
		x or y
		注：x，y 代表表达式
	作用：
		优先返回真值对象
		当x的布尔值为True时，返回x，否则返回y
	示例：
		True or True	#True
		True or False	#True
		False or True	#True
		False or False	#False
		0 or 0.0	#0.0
		100 or 200	#100

正负号运算符：
		+ （正号）
		- （负号）
	语法：
		+ 表达式
		- 表达式
	说明：
		这是一元运算符（只有一个数据参加运算）
	示例：
		a = 5
		b = -a
		c = +a


==============================================================
字符串 str
	作用：
		用来记录文本（文字）信息
	字符串的表示方式：
		在非注释中，凡是用引号括起来的部分都是字符串
		'	单引号
		"	双引号
		'''	三单引号
		"""	三双引号
	空字符串的字面值表示方法：
		''
		""
		''''''
		""""""
	非空字符串的表示方法：
		'hello'
		"hello"
		'''hello'''
		"""hello"""

单引和双引号的区别：
	单引号内的双引号不算结束符
	双引号内的单引号不算结束符
	示例：
		print("I'm a teacher!")		#I'm a teacher
		print('I am "weimingze"')	#I am "weimingze"

三引号字符串的作用：
	三引号字符串中的换行会自动转换为换行符
	三引号内可以包含单引号和双引号

	示例：
		s = 'welcome to beijing!\nI like python!\nI am studing!'
		print(s)
		s2 = '''welcome to beijing!
		I like python!
		I am studing!'''
		print(s2)

隐式字符串字面值拼接
	s = "I'm a teacher!" 'I am "weimingze"'

用转义序列代表特殊字符
	字符串字面值中，用字符反斜杠(\)
	后跟一些字符代表特殊的一个字符

反斜杠转义字符表：
	\'	单引号(')
	\"	双引号(")
	\\	一个反斜杠
	\n	换行
	\r	返回光标至行首
	\t	水平制表符
	\v	垂直制表符
	\f	换页
	\b	倒退
	\0	空字符，字符值为零
	\xXX	XX为两位十六进制表示的字符
	\uXXXX	XXXX为四个十六进制表示的Unicode16字符
	\UXXXXXXXX	8个十六进制表示的Unicode32字符

ASCII 编码：
	ASCII字符表：
	$ man ascii<回车>

常用的ASCII字符编码：
	字符	十进制	十六进制
	'0'	 48	  0x30
	'A'	 65	  0x41
	'a'	 97	  0x61

Unicode
	统一编码，分为Unicode16和Unicode32

序列的概念
	字符串就是序列

求序列的长度的函数len
	len（x）	返回字符串的字符个数

raw 字符串（原始字符串）
	格式：
		r'字符串内容'
		r"字符串内容"
		r'''字符串内容'''
		r"""字符串内容"""
	作用：
		让转义符号\无效
	示例：
		s = 'C:newfile\test.py'
		print(s)
		print(len(s))
		s = r'C:newfile\test.py'
		print(s)
		print(len(s))

字符串的运算
	+	加号运算符用于拼接字符串
	*	运算符用于生成重复的字符串
	示例：
		s = "ABC" + "DEF"	# s = 'ABCDEF'
		s2 = '123' * 3		# s2 = '123123123'
		s3 = 2 * 'ABC'		# s3 = 'ABCABC'
	注：字符串只能和整数相乘

	+= *= 运算符，与其他赋合赋值运算符规则相同

in / not in 运算符：
	作用：
		用于判断某个字符串是否在
		相当前字符中出现过。如果出现过返回True，否则返回False
	语法：
		对象 in 字符串
	示例：
		s = 'wecome to tarena!'
		'to' in s	#True
		'weimingze' in s	#False
		'e t' in s	# True

字符串的比较运算
	运算符：
		> >= < <= == !=
	规则：
		依次按编码值进行比较，直到最短的字符串结束为止
	示例：
		'A' < 'B'	#True
		'ABC' > 'ABB'	#True
		'ABC' > 'ACB'	#False
		
字符串的索引操作
	python的字符串时不可以改变的字符序列

索引 index
	语法：
		字符串[整数表达式]
	说明：
		python序列都可以用索引来访问序列中的对象
		python序列的正向索引是从0开始的，第二个索引为1，最后一个索引为len(s)-1
		python序列的反向索引是从-1开始的，-1代表最后一个，-2代表倒数第2个，以此类推，第一个是-len（s）
	示例：
		s = 'ABCDE'
		print(s[0])	# A
		print(s[1])	# B
		print(s[4])	# E
		print(s[-1])	# E
		print(s[-5])	# A


==============================================================================

字符串的格式化表达式
	作用：
		生成一定格式的字符串
	语法格式：
		格式字符串 % 参数值
		格式字符串 % （参数值1，参数值2，...）
	说明：
		格式化字符串中以%开头的为占位符，占位符的位置将用参数值替换
	示例：
		fmt = "name:%s,age:%d"
		name = "tarena"
		age = 15
		s = fmt % (name,age)	# s = 'name:tarena,age=15'
		print()

格式化字符串中的占位符和类型码：
	%s	字符串，使用str（obj）转为字符串
	%r	字符串，使用repr（obj）转为字符串
	%c	整数转为字符串，使用chr(i)函数
	%d	十进制整数
	%o	八进制整数
	%x	十六进制整数（字符a-f小写）
	%X	十六进制整数（字符A-F大写）
	%e	指数型浮点数（e小写）	如 2.9e+10
	%E	指数型浮点数（E小写）	如 2.9E+10
	%f，%F	浮点十进制形式
	%g，%G	进制数形式浮点或指数浮点自动转换
	%%	等同于一个%字符

占位符和类型码之间的格式语法：
	% [- + 0 宽度・精度] 类型码
	-	左对齐（默认是右对齐）
	+	显示正号
	0	左侧空白位置补零
	宽度：整个数据输出的宽度
	精度：保留小数点后多少位，默认6位
	示例：
		"%10d" % 123	# '       123'
		"%+10d" % 123	# '      +123'
		"%-10d" % 123	# '123       '
		"%10s" % "ABC"	# '       ABC'
		"%05d" % 123	# '00123'
		"%f" % 3.1415926535897932	# '3.141593'
		"%7.2f" % 3.1415926535897932	# '   3.14'


循环语句：
	while 语句
	for 语句

while 语句
	作用：
		根据一定条件，重复的执行一条语句或多条语句
	语法：
		while 真值表达式：
			语句块1
		else：
			语句块2
	说明：
		1.先执行真值表达式，测试布尔值是否为True或False
		2.如果真值表达式测试值为True，则执行语句1，然后再返回到第1步，重重进行测试
		3.如果真值表达式测试值为False，则执行else子句中的语句块2，然后结束此while语句
		  如果没有else子句，则直接结束此while语句的执行
		注：else子句部分可以省略（同if语句类似）
while语句的注意事项：
	要控制循环真值表达式的值来防止‘死循环’
	通常用真值表达式内的循环变量来控制循环条件
	通常在循环语句块内改变循环变量来控制循环次数和变量走向

while语句的嵌套
	while语句本身是语句，和其他语句一样，可以嵌套放入任何复合语句中

	示例：
		while 真值表达式：
		    ...
		    while 真值表达式2：
		        ...
		    else：
			...
		else：
		    ...
	
break 语句
	作用：
		用于循环语句（while，for）中，用来终止当前循环语句的执行
	说明：
		1.当break语句执行后，此循环语句break之后的语句将不再执行
		2.break语句通常和if语句组合使用
		3.break语句终止循环时，循环语句else子句的语句将不会执行
		4.break语句只能终止当前循环语句的执行，如果有循环嵌套时，不会跳出嵌套的外重循环
		5.brea语句只能在循环语句（while或for语句）内部使用
	
死循环
	死循环是指循环条件一直成立的循环
	死循环通常用break语句来终止循环
	死循环的else子句永远不会执行

示例：
	i=1
	while True：
	    n = int(input("请输入一个数"))
	    if n == i:
	        print("跳出循环")
		break
	print(i,n)
	i += 1




=================================================================================


for 语句
	作用：
		用来遍历可迭代对象的数据元素
可迭代对象是指能依次获取数据元素的对象
  可迭代对象包括:
    字符串str
    ----以下后再才讲----
    列表 list
    元组 tuple
    字典 dict
    集合 set
    ...
      语法:
    for 变量列表 in 可迭代对象:
        语句块1
    else:
        语句块2
说明：
	当循环内部用break语句终止循环时，else子句部分的语句不会执行

range() 函数：
	格式：
		range(stop)	从零开始，每次生成一个整数后加1操作，直到stop为止(不包含stop)
		range(start,stop[,step])从start开始，每次生成一个整数后移动step，直到stop为止(不包含stopo，且step可以是负数)
	详见：
		>> help(range)
	作用：
		用来创建一个生成一系列整数的可迭代对象（也叫整数序列生成器）
	说明：
		range函数调用返回的对象可用于for语句来进行一次迭代取出其中的整数
	示例：
		range(4)	# 0,1,2,3
		range(3,6)	# 3,4,5
		range(1,10,2)	# 1,3,5,7,9
		range(5,0,-2)	# 5,3,1
		range(4,0)	# 空

for 语句嵌套
	
continue 语句
	问题：
		如何让程序不再向下执行，重新开始一次新的循环
	
	continue语句的作用
		用于循环语句中（while，for语句），不再执行本次循环内continue之后的语句，重新开始一次新的循环
	说明：
		1.在while语句中执行continue语句，将会直接跳转到while语句的真值表达式处重新判断循环条件
		2.在for语句中，执行continue语句，将会从可迭代对象中取下一元素绑定变量后再次进行循环

循环总结
	语句：
		while语句
		for语句
			字符串str
			range（）函数返回的对象
		break语句：结束当前循环语句的执行
		continue语句：结束本次循环，重新开始新的循环

列表 list
	列表的定义：
		1.列表是一种容器（通常用来存储计算机的数据对象）
		2.列表是可以被改变的序列
		3.列表是由一系列特定元素组成的，元素与元素之间可能没有任何的关联关系，但他们之间有先后顺序关系
	
	创建空列表的字面值方式
		L = []		# L绑定空列表

	创建空列表的字面值方式
		L = [1,2,3,4]
		L = ['北京','上海','深圳','西安']
		L = [1,'Two',3.14,'四']
		L = [1,2，[3.1,3.2,3.3]，4]
	
	列表的构造函数list
		list()		生成一个空的列表，等同于[]
		list(iterable)	用可迭代对象创建一个列表
	示例：
		L = list()		# L = []
		L = list("hello")	# L = ['h','e','l','l','o']
		L = list(range(5,10,2))	# L = [5,7,9]

列表的运算：
	运算符：
		+	+=	*	*=
		+ 用于拼接列表
			x = [1,2,3]
			y = [4,5,6]
			z = x + y	# [1,2,3,4,5,6]
		+= 用于将右侧的可迭代对象的数据追加到原列表中
			x = [1,2,3]
			x += [4,5,6]	# x = [1,2,3,4,5,6]
			x = [1,2]
			x += "AB"	# x = [1,2,'A','B']
			x = [1,2]
			x += range(3)	# x = [1,2,0,1,2]
		* 用于生成重复的列表
			x = [1,2]*3	# x = [1,2,1,2,1,2]
			x = list("AB")
			x *= 2		# x = ['A','B','A','B']

列表的比较运算：
	运算符：
		< <= > >= == !=
	比较规则：
		同字符串比较规则完全相同
			[1,2,3] < [1,3,2]	#True
			...
		不同：
			[1,'two'] > ['two',1]	#TypeError 出错

列表是可迭代对象：
	L = [2,3,5,7,11]
	for x in L:
	    print(x)

列表的 in / not in 运算符：
	判断一个元素是否存在于列表中，如果存在返回True，否则返回False
	in 和 not in 的返回值相反
	示例：
		x = [1,'two',3,'四']
		3 in x		# True
		4 not in x	# True
		'3' in x	# False


===================================================================


列表的索引操作
	语法：
		列表[整数表达式]
	用法：
		等同于字符串的索引操作（索引分正向索引和反向索引，规则与字符串完全相同）
	列表的索引赋值
		列表是可变的序列，可以通过索引赋值改变列表中的元素
	
列表的切片
	列表[:]
	列表[::]
	列表的切片取值返回一个列表，规则等同于字符串的切片规则

列表的切片赋值：
	作用：
		可以改变原列表的排序，可以插入和修改数据
		可以用切片改变列表对应的元素的值
	语法：
		列表[切片slice] = 可迭代对象
	说明：
		赋值运算符的右侧必须是一个可迭代对象
	示例：
		L = [2,3,4]
		L[0:1] = [1.1,2.2]	# L = [1.1, 2.2, 3, 4]
		L[2:] = [3.3, 4.4, 5.5]

切片赋值注意事项：
	对于步长不等于1的切片赋值，赋值运算符的右侧的可迭代对象
	提供的数据元素的个数一定要等于切片切出的片数

del语句用于删除列表的元素
	语法：
		del 列表[索引]
		del 列表[切片]

python3 中常用的序列相关的函数
 序列有5种：
	str，list，tuple，bytes，bytearray

len(x)	返回序列的长度
max(x)	返回序列的最大值元素
min(x)	返回序列的最小值元素
sum(x)	返回序列中所有元素的和（元素必须是数值类型）
any(x)	真值测试，如果列表中其中一个值为真值则返回True
all(x)	真值测试，如果列表中所有值为真值则返回True

列表中常见的方法(method)
	详见
	>>> help(list)

字符串的文本解析方法split和join
S代表字符串
	S.split（sep=None）  将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时，用空白字符作为分隔符分割
	S.join（iterable）
	用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串


浅拷贝 和 深拷贝
浅拷贝 shallow copy
	浅拷贝是指在复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程

深拷贝


列表推导式 list comprehension
	列表推导式是用可迭代对象生成列表的表达式

	作用：
		用简易方法生成列表
	语法：
		[表达式 for 变量 in 可迭代对象]
		或
		[表达式 for 变量 in 可迭代对象 if 真值表达式]
	说明：
		for in 表达式的if子句可以省略，省略后将对所有生成的对象进行求值处理

	示例：
	# 生成一个数值为1~9的平方列表
	L = [x**2 for x in range(1,10)]

列表推导式的嵌套:
	语法：
		[表达式 
			for 变量1 in 可迭代对象1 if 真值表达式1
				for 变量2 in 可迭代对象2 if 真值表达式2]


==================================================================================


元组	tuple
	元组是不可变的序列，同list一样，元组可以存放任意类型数据的容器

元组的表示方法：
	用小括号()括起来，单个元素括起来后加逗号（，）
	区分单个对象还是元组

创建空元组的字面值：
	t=（）	空元组

创建非空元组的字面值表示：
	t=200，
	t=（20，）
	t=（1,2，3）
	t=100,200,300

函数type(x) 用来返回x对应的类型
元组的错误示例：
	t=（20）	# t 绑定20这个对象，不是元组
	x，y，z = 100,200,300	# 序列赋值
	x，y，z = (100,200,300)	# 序列赋值
	x，y，z = [100,200,300]	# 序列赋值
	x，y，z = 'ABC'		# 序列赋值

元组的构造(创建)函数tuple
	tuple()		生成一个空元组，等同于()
	tuple(iterable)	用可迭代对象生成一个元组

元组的运算：
	+ += * *=
	< <= > >= == !=
	in , not in
	索引[]，切片[:]/[::]

+ 加号用于拼接元组
* 用于生成重复的元组


元组的比较运算：
	规则与列表的比较规则完全相同

in / not in	运算符
	规则写列表的规则完全相同


索引和切片
	索引取值和切片取值的规则与列表完全相同
	元组不支持索引赋值和切片赋值(因为元组不可被改变)

元组的方法：
	T.index(v[,begin[,end]])	返回对应元素的索引下标
	T.count(x)			返回元组中对应的元素个数

序列相关的函数：
	len(x),max(x),min(x),sum(x),any(x),all(x)

构造函数:
	str(x)		创建字符串
	list(iterable)	创建列表
	tuple(iterable)	创建元组


reversed (可迭代对象)	返回反向顺序的可迭代对象
sorted (iterable, key=None, reverse=False)	返回已排序的列表


容器小结：
	字符串	str	# 不可变序列，只能存字符
	列表	list	# 可变的序列，可以存任意数据
	元组	tuple	# 不可变的序列，可以存任意数据


字典 dict
	
什么是字典：
	1.字典是一种可变的容器，可以存储任意类型的数据
	2.字典中的每个数据都是用'键'(key)
	进行索引，而不像序列可以用整数下标来进行索引
	3.字典中的数据没有先后关系，字典的存储是无序的
	4.字典中的数据以键'key'-值(value)对形式进行映射存储
	5.字典的键不能重复，且只能用不可变类型作为字典的键

字典的字面值表示方法：
	字典的表示方式以{}括起来，以冒号(:)
	分隔键-值对，各键-值对之间用逗号分割开
创建空字典的字面值：
	d = {}		# d 绑定空字典

创建非空字典的字面值：
	d = {'name': 'weimingze', 'age': 35}

字典的构造函数dict
	dict()	生成一个字的字典等同于{}
	dict(iterable)	用可迭代对象初始化一个字典
	dict(**kwargs)	用关键字传参形式创建一个字典


字典的键(key)必须为不可变类型
	bool，int，float，complex，str，tuple
	frozenset，bytes(后面讲)

字典的值(value)可以是任意类型

可变的数据类型有四种：
	lsit		列表
	dict		字典
	set		集合
	bytearray	字节数组

字典的基本操作
	字典的键索引
		用[]运算符可以获取字典内'键'对应的值
		也可以用[]运算符来修改'键'对应的值
	键索引的语法：
		字典[键]

添加/修改字典的元素
	语法：
		字典[键] = 值
	说明：
		键不存在时，创建键，并绑定对应的值
		当键存在时，修改键绑定的值

删除字典元素
	del 字典[键]


字典的成员资格判断 in 运算符
	可以用in运算符判断一个键是否存在于字典中，如果存在则返回True，否则返回False
	not in 与 in 结果相反

字典的迭代访问
	字典是可迭代对象，字典只能对键进行迭代访问

可以用于字典的内建函数
	len(x)	返回字典的键值对个数
	max(x)	返回字典的键的最大值
	min(x)	返回字典的键的最小值
	sum(x)	返回字典中所有键的和
	any(x)	真值测试，只对键进行测试，只要有一个键为True，返回True
	all(x)	真值测试，当全部键为真值是，返回True


字典推导式：
	字典推导式是用可迭代对象创建字典的表达式

	语法：
		{键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}
	说明：
		if 子句部分可省略
	

字典	vs	列表
	1. 都是可变对象
	2. 索引方式不同，列表用整数索引，字典用键索引
	3. 字典的插入，删除，修改数据的速度可能会快于列表（重要）
	4. 列表的存储是有序的，字典的存储是无序的


=======================================================================================


集合	set
	集合是可变的容器
	集合内的数据对象都是唯一的（不能重复多次的）
	集合是无序的存储结构，集合中的数据没有先后关系
	集合内的元素必须是不可变对象
	集合是可迭代对象
	集合是相当于只有键没有值得字典（键则是集合的数据）

创建空集合
	s = set()

创建非空集合
	s = {1,2,3}
	s = {3.14，True，(1970.1.1)，"hello"}


集合的构造函数 set
	set()	创建一个空的集合对象(不能用{}创建空集合)
	set(iterable)	用可迭代对象创建一个新的集合对象


集合的运算：
	交集，并集，补集，子集，超集

	& 生成两个集合的交集
	| 生成两个集合的并集
	- 生成两个集合的补集
	^ 生成两个集合的对称补集
	> 判断一个集合是另一个集合的超集
	< 判断一个集合是另一个集合的子集

	== !=	集合相同/不同

in , not in 运算符
	等同于字典in，not in
	作于集合中，判断某个值是否存在于集合中

集合和字典的优点：
	in / not in 运算符得判断速度快些

能用于集合的函数：
	
	len(x),max(x),min(x),sum(x),any(x),all(x)

python3 中常用的集合方法
	

集合推导式
	集合推导式是用可迭代对象生成集合的表达式

	语法：
		{表达式 for 变量 in 可迭代对象 [if 真值表达式]}

集合推导式可以嵌套：
	语法同列表推导式一致！

固定集合  frozenset
	固定集合是不可变得，无序的，含有唯一元素的集合
	作用：
		固定集合可以作为字典的键，还可以作为集合的值

	固定集合的构造函数：
		frozenset()	创建一个空的固定集合
		frozenset(iterable)	用可迭代对象创建固定集合

固定集合的运算：
	& 交集，   | 并集，    - 补集，    ^ 对称补集
	<  <=  >  >=  ==  !=
	in / not in
	(以上运算符和集合set中的用法完全一致)

固定集合的方法
	相当于集合的全部方法去掉修改集合的方法
















1.数据类型：
	数值类型：
		int，float，complex，bool
	容器：
		不可变的容器
			str，tuple，frozenset，bytes
		可变的容器
			list，dict，set，bytearray

2.值：
	None，False，True

3.运算符：
	算术运算符：
		+  -  *  /  //  %  **
	比较运算符：
		<  <=  >  >=  ==  !=
		in / not in
		is, is not
	布尔运算：
		not，and，or
	+(正号)  -(负号)
	&  |  ^
	[]  (索引,切片,键索引)

4.表达式：
	1
	1 + 2
	max(1,2,3)		# 函数调用是表达式
	x if x > y else y,	# 条件表达式
	三种推导式：
		列表，字典，集合推导式(三种)

5.语句:
	表达式语句:
		所有的表达式都可以单独写在一行,形成一个语句
			例:print("hello world!")
	赋值语句:
		a = 100
		a = b = c = 100
		x,y = 100,200
		a[0] = 100
		dict['name']='tarena'
	del 语句
	if 语句
	while 语句
	for 语句
	break 语句
	continue 语句
	pass 语句

6.内建函数:
	len(x),max(x),min(x),sum(x),any(x),all(x)
	构造函数(用来创建同类型的数据对象)
		bool(x),int(x),float(x),complex(x),
		list(x),tuple(x),str(x),dict(x),
		set(x),frozenset(x)
	abs(x)
	round(x)
	pow(x,y,z=None)

	bin(x),oct(x),hex(x)
	chr(x),ord(x)
	range(start,stop,step)
	input(x),print(x)

	>>> help(__builtins__)


函数 function
	什么是函数：
		函数是可以重复执行的语句块，可以重复调用
	作用：
		1.用于封装语句块,提高代码的重用性
		2.定义用户级别的函数

	语法:
		def 函数名(形参列表):
		    语句块
	说明:
		1.函数的名字就是语句块的名称
		2.函数名的命名规则与变量名相同(函数名必须是标识符)
		3.函数名是一个变量(不要轻易对其赋值)
		4.函数有自己的名字空间,在函数外部不可以访问函数内部的变量,
		  在函数内可以访问函数外部的变量,但不能修改此变量
		5.函数如果不需要传入参数,形参列表可以为空
		6.语句部分不能为空,如果为空需要填充pass

函数调用
	函数名(实际调用传递参数)
		注:实际调用传递参数,以后简称实参

	说明:
		1.函数调用是一个表达式
		2.如果函数内部没有 return 语句,函数调用完毕后返回 None 对象
		3.如果函数需要返回其他的对象需要用到 return 语句

return 语句
	语法:
		return [表达式]
		注: [] 代表可省略
	作用:
		用于函数中,结束当前函数的执行,返回到调用该函数的地方,同时返回一个对象的引用关系

	return 语句说明
		1.return 语句后跟的表达式可以省略,省略后相当于renturn None
		2.如果函数内没有return语句,则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)

==============================================================================================================

函数的参数传递
	传递方式：
		位置传参
			序列传参
		关键字传参
			字典关键字传参

位置传参：
	实际参数(实参)的对应关系与形式参数(形参)
	的对应关系是按位置来依次对应的

序列传参:
	序列传参是指在函数调用过程中,用 *
	将序列拆解后按位置进行传递的传参方式

	说明:
		序列传参时,序列拆解的位置将与形参一一对应
		序列的位置信息对应相应的形参位置

关键字传参:
	关键字传参是指传参时,按照形参的名称给形参赋值
	实参和形参按形参名进行匹配

字典关键字传参:
	是指实参为字典,将字典用 '**' 
	拆解后再进行关键字传参的传参方式

	说明:
		字典的键名和形参名必须一致
		字典的键名必须为字符串(标识符)
		字典的键名要在形参中存在

函数的综合传参:
	函数的传参方式在能确定形参能唯一匹配到相应实参的情况下可以任意组合

	说明:
		位置传参(序列传参)要在关键字传参(字典关键字传参)的左侧




----------函数形参的定义----------

函数的缺省参数:
	语法:
		def 函数名(形参名=默认实参1,形参名2=默认实参2,...):
		    语句块
	说明:
		缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其右侧的所有参数都必须有缺省参数

		如:
			def fe(a,b=10,c):	# 错误
			    pass

函数形参的定义方式:
	1.位置形参
	2.星号元组形参
	3.命名关键字形参
	4.双星号字典形参

位置形参:
	语法:
		def 函数名(形参名1,形参名2,...):
		    语句块

星号元组形参:
	语法:
		def 函数名(*元组形参名):
		    语句块
	作用:
		收集多余的位置传参
	
命名关键字形参:
	语法:
		def 函数名(*,命名关键字形参):
		    语句块
		或
		def 函数名(*args,命名关键字形参):
		    语句块
	作用:
		强制所有的参数都必须用关键字传参或字典关键字传参


双星号字典形参:
	语法:
		def 函数名(**字典形参名):
		    语句块
	作用:
		收集多余的关键字传参
	说明:
		字典形参名通常命名为'kwargs'

函数的参数说明:
	位置形参,缺省参数,星号元组形参,双星号字典形参可以混合使用

	函数形参自左至右的顺序为:
		位置形参
		星号元组形参
		命名关键字形参
		双星号字典形参

函数的不定长参数:
	星号元组形参,双星号字典形参

	说明:
		可以接受任意的位置传参和关键字传参
	
全局变量和局部变量
	局部变量: local variable
		1.定义在函数内部的变量称为局部变量(
		  函数的形参也是局部变量)
		2.局部变量只能在函数内部使用
		3.局部变量在函数调用时才能够被创建,在
		  函数调用之后会自动销毁

	全局变量: global variable
		定义在函数外部,模块内部的变量称为全局变量
		全局变量所有函数都可以直接访问(但
		函数内不能将其直接赋值)

====================================================================================================

globals() /locals()函数:
	globals()	返回当前全局作用域内变量的字典
	locals()	返回当前局部作用域内变量的字典


函数变量
	函数名是变量,它在def 语句创建函数时绑定一个函数




一个函数 可以作为另一个函数的实参传递



函数可以作为另一个函数的返回值


函数的嵌套定义
	函数嵌套定义是指一个函数里用def 语句来创建其他的函数的情况

python的作用域
	作用域也叫名字空间,是访问变量时查找变量名的范围空间

python的四个作用域:
	作用域			英文解释			英文缩写
局部作用域(函数内)		Local(function)			 L
外部嵌套函数作用域		Enclosing function locals	 E
函数定义所在模块(文件)作用域	Global(module)			 G
python内建模块的作用域		Builtin(Python)			 B


变量名的查找规则
	在变量访问时,先查找本地变量,然后是包裹此函数外部的函数内部的变量,之后是全局变量,最后是内建变量


global语句
	作用:
		1.告诉解释执行器global语句声明的一个或多个变量,这些变量的作用域为模块级的作用域,也称作全局变量
		2.全局声明(global)
		将赋值语句操作的变量映射到模块文件内部的作用域

	语法:
		global 变量1,变量2,...
	
	说明:
		1.全局变量如果要在函数内部被赋值,则必须经过全局声明(否则会被认为是创建局部变量)
		2.全局变量在函数内部不经过声明就可以直接访问(变量已经存在并关联一个对象)
		3.不能先声明局部变量,再用global声明为全局变量,此做法不符合规则
		4.global变量列表里的变量名不能出现在此作用域的形参列表里


nonlocal 语句
	作用:
		告诉解释执行器,nonlocal声明的变量不是局部变量,也不是全局变量,它是外部嵌套函数内的变量
	
	语法:
		nonlocal 变量名1,变量名2,...
	
	说明:
		1.nonlocal 语句只能在被嵌套的函数内部进行使用
		2.访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
		3.当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近的一层变量进行操作
		4.nonlocal语句的变量列表里的变量名,不能出现在此函数的参数列表中


lambda 表达式(又称匿名函数)
	作用:
		创建一个匿名函数对象
		同def 类似,但不提供函数名
	格式:
		lambda[参数1,参数2,...]: 表达式
	
	说明:
		1.lambda只是一个表达式,它用来创建一个函数对象
		2.当lambda表达式调用时,先执行冒号(:)后的
		  表达式,并返回表达式的结果的引用关系
		3.lambda表达式创建的函数只能包含一条表达式
		4.lambda比函数简单且可以随时创建和销毁,有利于减少程序的偶合度

eval() / exec() 函数

	eval(source,globals=None,local=None)
	把一个字符串 srouce
	当成一个表达式来执行,返回表达式执行的结果

	exec(source,globals=None,locals=None)
	把一个字符串source当成程序来执行


====================================================================================

函数式编程
	函数式编程是指用一系列函数解决问题
	
	好处：
		1.用每一个函数完成细小的功能,一系列函数的任意组合可以完成大问题
		2.函数仅接受输入并产生输出,不包含任何能影响输出的内部状态
		
	函数的可重入性
		如果一个函数的输入参数一定,则返回结果必须一定的函数称为可重入函数       

	# 不可重入函数:
		y=200
		def myadd(x):
		    return x + y
		print(myadd(10))   # 210
		y = 300
		print(myadd(10))   # 310

	函数式编程的要求:
		def 创建的函数最好不要访问局部作用域以外的变量,
		这样可以保证结果的唯一性(可重入性)

	
高阶函数 High Order Function
	什么是高阶函数:
		满足下列条件之一的即为高阶函数
			1.函数接受一个或多个函数作用参数传入
			2.函数返回一个函数
			
python内建的高阶函数:
	map,filter,sorted
	
map函数:
	格式:
		map(func, *iterables)
	说明:
		用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象,
		当最短的一个可迭代对象不再提供数据时此可迭代对象生成结束

filter函数:
	filter(function,iterable)
	筛选可迭代对象iterable中的数据,返回一个可迭代器对象，此可迭代对象
	将对iterable进行筛选.函数function 将对iterable中的每个元素进行求值，
	返回False则将此数据丢弃，返回True，则保留此数据

sorted函数
	作用:
		将原可迭代对象的数据进行排序，生成排序后的列表
	格式:
		sorted(iterable, key=None, reverse=False)
	说明:
		iterable可迭代对象
		key函数是用来提供一个值,这个值将作为排序的依据
		reverse标志用来设置是否降序排序

递归函数 recursion
	函数直接或间接的调用自身

	递归说明:
		递归一定要控制递归的层数,当符合一定条件时要终止递归
		几乎所有的递归都能用while循环来代替

	递归的优缺点:
		优点:
			递归把问题简单化,让思路更为清晰,代码更简洁
		缺点:
			递归因系统环境影响大,当递归深度太大时,可能会得不到不可预知的结果

	递归的两个阶段
		递推阶段:
			从原问题出发按递归公式递推从未知到已知,最终达到递归的终止条件
		回归阶段:
			按递归终止条件求出结果,逆向逐步代入递归公式,回归到原问题求解

	
闭包 closure
	什么是闭包:
		闭包是指引用了此函数外部变量的函数

	说明:
		在本质上,闭包是将内部嵌套函数和函数外部的执行环境绑定在一起的对象

	闭包必须满足三个条件:
		1.必须有一个内嵌函数
		2.内嵌函数必须引用外部函数中的变量
		3.外部函数返回值必须是内嵌函数


===================================================================================================

装饰器 decorators(专业提高篇)
	装饰器是一个函数,主要作用是用来包装另一个函数或类(后面讲)

	装饰的目的是在不改变原函数名(或类名)的情况下,改变被包装对象的行为

函数装饰器
	函数装饰器指装饰器传入的是一个函数,返回的也是一个函数

	语法:
		def 装饰器函数名(参数):
		    语句块
		    return 函数对象
	
		@装饰器函数名<换行>
		def 函数名(形参列表):
		    语句块
		
函数的文档字符串
	函数内第一次未被赋值给任何变量的字符串是此函数的文档字符串

	语法:
		def 函数名(参数列表):
		    '函数文档字符串'
		    函数语句块

	说明:
		1.文档字符串通常用来说明本函数的功能和使用方法
		2.在交互模式下输入:help(函数名)
		  可以查看函数的'文档字符串'
		3.函数的文档字符串绑定在函数的 __doc__ 属性上

函数的 __doc__ 属性
	用于绑定函数的文档字符串

函数定义语句(def 语句)的完整语法:
	[@装饰器1]
	[@装饰器2]
	[...]
	def 函数名([位置形参],[*元组形参],[命名关键字形参],[**字典形参]):
	    '''文档字符串'''
	    语句块

	注:[]代表其内部可以省略


模块  Module
	什么是模块:
		模块是一个包含有一系列数据,函数,类等组成的程序组
		模块是一个文件,模块文件名通常以.py结尾


	作用:
		让一些相关的数据,函数,类等有逻辑的组织在一起,使逻辑结构更加清晰
		模块中的数据,函数,类等可提供给其他模块或程序使用


	模块的分类:
		内建模块(builtins)在解析器的内可以直接使用
		标准库模块,安装python时已安装且可以直接使用
		第三方模块(通常开源),需要自己安装
		用户自己编写的模块(可UI作为其他人的第三方模块)

模块的导入语句 
import 语句
	语法:
		import 模块名1 [as 模块新名1],模块名2 [as 模块新名2],...

	作用:
		将某模块整体导入到当前模块中

	用法:
		模块名.属性名
		或
		模块名.函数属性名(实参传参)

	dir(obj) 函数返回所有属性的字符串列表
	help(obj) 函数可以查看模块的相关文档字符串

from import
	语法:
		from 模块名 import 模块属性名1 [as 属性新名1],
		模块属性名2 [as 属性新名2], ...
	作用:
		将某模块的一个或多个属性导入到当前模块的作用域
	
from import * 语句
	语法:
		from 模块名 import *
	作用:
		将某模块的所有属性导入到当前模块

dir 函数:
	dir([对象])	返回一个字符串的列表

	说明:
		如果没有给参数调用,则返回当前作用域内的所有变量的列表
		如果给定一个对象作为参数,则返回这个对象的所有的变量的列表
			1) 对于一个模块,返回这个模块的全部属性
			2) 对于一个类,返回这个类的所有变量,并递归基类对象的所有变量
			3) 对于其它的对象,返回所有变量类变量和基类变量


内建模块

math 模块
	模块名 math



时间模块 time
	

系统模块 sys
	



============================================================================================


自定义模块并导入
	
	注意事项:
		自定义模块的文件要求以.py结尾,文件名必须是标识符的规则

导入 import 语句等  搜索块的路径顺序
	搜索顺序:
		1.搜索程序运行时的路径(当前路径)
		2.sys,path提供的路径
		   sys.path是一个列表,里面放的都是模块的搜索路径
		3.搜索内建模块


模块的加载过程:
	1.在模块导入时,模块的所有语句都会执行
	2.如果一个模块已经导入,则再次导入时不会重新执行模块内的语句


模块的重新加载
	import mymod
	import imp
	imp.reload(mymod)	# 重新加载mymod


模块以导入和执行的过程:
	1.先搜索相关的路径,找到模块名.py
	2.判断是否有此模块对应的.pyc文件。如果.pyc比.py文件新,则直接加载.pyc文件
	3.否则用模块.py,文件生成.pyc,并加载执行

pyc python的编译
		     编译		解释执行
	mymod.py  -------->  mymod.pyc  -------->  python3

模块的文档字符串:
	模块内第一个没有赋值给任何变量的字符串称为模块的文档字符串

	模块的 __doc__ 属性
		此属性用于绑定模块的文档字符串

	模块的 __file__ 属性
		此属性用于记录模块对应的文件路径名

	模块的 __name__ 属性
		__name__ 属性 用来记录模块自身名字

		作用:
			1.记录模块名
			2.用来判断是否为主模块
		说明:
			当模块为主模块(也就是第一个运行的模块时)运行时,
			__name__绑定'__main__'
			当此模块不是主模块时,而是被其他模块导入时,此时
			__name__绑定模块名

模块的 __all__ 列表
	模块中的 __all__ 列表是一个用来存放可导出属性的字符串列表

	作用:
		当用 from xxx import *
		语句导入时,只导入__all__列表内的属性

模块的隐藏属性
	模块中以'_'开头的属性,在from xxx import *
	导入时,将不被导入,通常称这些属性为隐藏属性

随机模块 random
	模块名 random
		作用:
			用于模拟或生成随机输出的模块

包(模块包) package
	包的定义
		包是将模块以文件夹的组织形式进行分组管理的管理方法
	作用:
		将一系列模块进行分类管理,有利于防止命名冲突
		可以在需要时加载一个或部分模块则不是全部模块

__init__.py 文件
	__init__.py是常规包内必须存在的文件
	__init__.py会在包加载时自动调用

	作用:
		1.编写此包的内容
		2.在内部填写文档字符串
		3.在__init__.py文件内可以加载此包所依赖的一些其他模块

包的导入
	同模块的导入规则
	# import 语句
	import 包名 [as 包新名]
	import 包名.模块名 [as 模块新名]
	import 包名.子包名.模块名 [as 模块新名]

	# from import语句
	from 包名 import 模块名 [as 模块新名]
	from 包名.子包名 import 模块名 [as 模块新名]
	from 包名.子包名.模块名 import 属性名 [as 属性新名]

	# from import *语句
	from 包名 import *
	from 包名
	...


导入包时的索引路径顺序:
	1.搜索程序的当前路径
	2.sys.path 提供的路径


__init__.py内的 __all__ 列表
	作用:
		用来记录此包中有哪些子名或模块在用from import *语句
		时被导入
	说明:
		__all__列表只对 from xxx improt *语句起作用
	

包的相对导入:
	包的相对导入是指包内模块的相互导入

	语法:
		from 相对路径包或模块 import 属性或模块名
		from 相对路径包或模块 import *
	相对路径
		. 代表当前目录
		.. 代表上一级目录
		... 代表上二级目录
		.... 以此类推

		注:相对导入时不能超出包的外部



==============================================================================================

异常(基础) except
	什么是错误
		错误是指由于逻辑或语法等导致一个程序已无法正常执行的问题
	
	什么是异常
		异常是程序出错时标识的一种状态
		当异常发生时,程序不会再向下执行,而转去调用此函数的地方待处理此异常并恢复为正常状态
	
	异常作用:
		用作信号,通知上层调用者有错误产生需要处理

try 语句:
	两种语法:
		try-except语句
		try-finally语句
	
	try-except语句语法:
		try:
		    可能触发异常的语句
		except 错误类型1 [as 变量1]:
		    异常处理语句1
		except 错误类型2 [as 变量2]:
		    异常处理语句2
		except (错误类型3,错误类型4,...) [as 变量3]:
		    异常处理语句3
		...
		except:
		    异常处理语句(其他)
		else:
		    未发生异常语句
		finlly:
		    最终语句
	作用:
		尝试捕获异常,将程序由异常状态转为正常状态并正常执行

	try-except语句说明:
		1.as 子句是用于绑定错误对象的变量,可以省略
		2.except 子句可以有一个或多个,但至少要有一个
		3.else子句最多只能有一个,也可以省略不写
		4.finally子句最多只能有一个,也可以省略不写
		5.else子句的语句将再次try语句没有发生异常时被执行
		6.finally子句的语句在任何情况下都会被执行

python中全部的错误类型
	参见文档
	
try-finally语句
	语句:
		try:
		    可能触发异常的语句:
		finally:
		    最终语句
	
	说明:
		1.finally 子句不可以省略
		2.一定不存在except子句
	作用:
		通常用try-finally语句来做触发异常时必须要处理的事情
		无论异常是否发生,finally子句都会被执行
	注意:
		try-finally 语句不会改变程序的(正常/异常)状态

raise语句
	作用:
		触发一个错误,让程序进入异常状态
	语法:
		raise 异常类型
		或
		raise 异常对象

assert 语句(断言语句)
	语法:
		assert 真值表达式,错误数据(通常是字符串)
	作用:
		当真值表达式为False时,用错误数据创建一个AssertionError
		类型的错误,并进入异常状态
	等同于:
		if 真值表达式 == False
		    raise AssertionError(错误数据)

小结:
	异常处理语句(四条):
		try-except 语句:
			用于接收异常通知,捕获异常
		try-finally 语句:
			执行必须要执行的语句
		raise 语句:
			发送异常通知,并进入异常状态
		assert 语句:
			根据条件选择性的发送AssertionError类型的异常通知


为什么要异常处理机制:
	在程序调用层数较深时,向主调函数传递错误信息需要层层return
	返回比较麻烦,用异常处理机制可以较简单的传送错误信息


=======================================================================================
迭代器 Iterator
	
	什么是迭代器
		迭代器是访问可迭代对象的工具
		迭代器是指用iter(obj)函数返回的对象(实例)
		迭代器可以用next(it)函数获取可迭代对象的数据

	迭代器函数 iter和 next
		iter(iterable)从可迭代对象中返回一个迭代器,iterable必须是能提供一个迭代器的对象
		next(iterator)从迭代器iterator中获取下一个记录,如果无法获取下一条记录,则触发StopIteration异常

		说明:
			迭代器只能向前取值,不会后退
			用iter函数可以返回一个可迭代对象的迭代器
		作用:
			迭代器对象能用next函数获取下一个元素


生成器 Generator (python 2.5 及以后)
 什么是生成器:
	生成器是能够动态提供数据的对象,生成器对象也是可迭代对象(实例)

生成器有两种:
	1.生成器函数
	2.生成器表达式

生成器函数的定义
	含有yield语句的函数是生成器函数,此函数被调用将返回一个生成器对象
	yield 翻译为(产生或生成)

yield 语句
	语法:
		yield 表达式
	说明:
		yield 用于 def 函数中,目的是将此函数作用生成器函数使用
		yield 用来生成数据,供迭代器的next(it)函数使用
 
生成器函数说明:
	生成器函数的调用将返回一个生成器对象,生成器对象是一个可迭代对象
	在生成器函数调用return会触发一个StopIteration异常



生成器表达式:
	语法:
		(表达式 for 变量 in 可迭代对象 [if 真值表达式 ])

	说明:
		if 子句可以省略
	作用:
		用推导式的形式创建一个新的生成器



迭代工具函数
	迭代工具函数的作用是生成一个个性化的可迭代对象

	zip(iter1[,iter2[,...]]) 返回一个zip对象,此对象用于生成元素,此元组的个数由最小的可迭代对象决定

	enumerate(iterable[,start])
	生成带索引的枚举对象,返回迭代类型为索引-值对(index-value对),默认索引从零开始,也可以用start指定


字节串和字节数组
字节串 bytes (也叫字节序列)
	作用:
		存储以字节为单位的数据
		字节串是不可变的字节序列
	
字节:
	字节是由8个位 (bit) 组成的数据单位,是计算进行数据管理的单位
	字节是用 0 ~ 255 范围内的整数表示的


创建空字节串的字面值
	B = b''
	B = b""
	B = b''''''
	B = b""""""
创建非空字节串的字面值
	B = b'ABCD'
	B = b"ABCD"
	B = b'\x41\x42'

字节串的构造函数 bytes
	bytes() 生成一个字的字节串 等同于 b''
	bytes(整数可迭代对象)	# 用可迭代对象初始化一个字节串
	bytes(整数n)	生成n个值为0的字节串
	bytes(字符串, encoding='utf-8')
	用字符串转为编码生成一个字节串


bytes 的运算
	+  +=  *  *=
	<  <=  >  >=  ==  !=
	in / not in
	索引和切片

	len(x)
	max(x)
	min(x)
	sum(x)
	any(x)
	all(x)


bytes 和 str 区别
	bytes 存储字节(通常值 range(0,256))
	str 存储 unicode 字符( 通常值在0 ~ 65535)

bytes 与 str 的转换
	编码(encode)
	str ---------------> bytes
		b = s.encode(encoding='utf-8')

		解码(decode)
	bytes --------------> str
		s = b.decode(encoding='utf-8')


字节数组 bytearray
	可变的字节序列

字节数组的构造函数: bytearray
	bytearray() 	创建空的字节数组
	bytearray(整数) 	用可迭代对象初始化一个字节数组
	bytearray(整型可迭代对象) 	生成n个值为0的字节数组
	bytearray(字符串, encoding='utf-8') 	用字符串的转换编码生成一个字节数组
	用字符串的转换编码生成一个字节数组

	
bytearray 的运算
	+  +=  *  *=
	<  <=  >  >=  ==  !=
	in / not in
	索引和切片
	(字节数组支持索引和切片的赋值操作,规则同列表的索引和切片赋值规则)


bytearray的方法:
	BA.clear()清空
	BA.append(n)追加一个字节(n为0 ~ 255的整数)
	BA.remove(value)删除第一个出现的字节,如果没有出现,则触发ValueError错误
	BA.reverse() 字节顺序反转
	BA.decode(encoding='utf-8')	# 解码为字符串
	BA.find(sub[,start[,end]])	# 查找 sub




=====================================================================================
文件 File
	文件是用于数据存储的单位
	文件通常用来长期存储数据
	文件中的数据是以字节为单位进行顺序存储的

文件的操作流程：
	1.打开文件
	2.读/写文件
	3.关闭文件
	注:任何的操作系统,一个应用程序同时打开文件的数量有最大数限制

文件的打开函数
	open(file,mode='rt') 
	用于打开一个文件,返回此文件流对象,如果打开文件失败,则会触发OSError错误

文件的关闭方法:
	F.close()	# 关闭文件,释放系统资源

文本文件操作
	操作模式:
		't'
	说明:
		1.默认文件中存储的都为字符数据,在读写过程中会自动进行编解码操作,
		2.文本文件以行为单位进行分隔,在python内部统一用'\n'作为换行符进行分隔
		3.对文本文件的读写操作需要用字符串(str)进行数据操作
		
	各操作系统的换行符
		Linux换行符: '\n'
		Windows 换行符: '\r\n'
		新的Mac OS 换行符: '\n'
		旧的Macintosh 换行符: '\r'(已不用了)

文件流对象是可迭代对象,迭代过程中将以换行符'\n'作为分隔符


标准输入输出文件:
	sys.stdin	标准输入文件
				ctrl+d 输入文件结束符
	sys.sdout	标准输出文件
	sys.stderr	标准错误输出文件
	注:标准文件不需要打开和关闭就可以使用


二进制文件操作:
	二进制文件操作模式字符: 'b'
	
	默认的文件中存储的是以字节为单位数据,通常有人为规定的格式
	二进制文件操作需要用字节串进行读写

F.read()/F.readline()/F.readlines() 返回类型
	对于文本文件,F.read()等函数返回为字符串(str)
	对于二进制文件,F.read()等函数返回为字节串(bytes)


F.write() 对于二进制文件与需要用字节串进行操作


F.tell方法:
	作用:
		返回当前的读写位置(从文件头以字节为单位)
	
F.seek方法:
	作用:
		设置读写位置

	F.seek(偏移量,whence=相对位置)
	偏移量
		大于0的数代表向文件末尾方向移动的字节数
		小于0的数代表向文件头方向中移动的字节数
	相对位置
		0 代表从文件头开始偏移
		1 代表从文件当前读写位置开始偏移
		2 代表从文件尾开始偏移

汉字编码(只讲两种)
	国标系列:
		GB18030 (二字节或四字节编码,共27533个字)
		  GBK     (二字节编码,共21003个字)
		    GB2312  (二字节编码,共6763个汉字)
		(Windows常用)
	国际标准: UNICODE <---> UTF-8
		(Linux / Mac OS X / IOS / Android 等常用)

	问题:
		十个汉字占多少字节
		UTF-8		30个字节


python 编码字符串:
	'gb2312'
	'gbk'
	'gb18030'
	'utf-8'
	'ascii'
	...
	以上字符串用于encode和decode中

编码注释:
	在python源文件的第一行或第二行写入如下内容:
		# -*- coding:gbk -*-
		# 设置源文件编码格式为gbk
		或
		# -*- coding:utf-8 -*-
		# 设置源文件编码格式为utf-8
	作用:
		告诉解释执行器,此前文件的编码是什么?

=================================================================


面向过程编程:
	函数做单位


面向对象编程 Ojbect-Oriented Programing
	什么是对象:
		对象是指现实中的物体或实体

	对象有什么特征:
		对象有很多属性(名词,形容词)
			姓名,年龄,性别
		对象有很多行为(动作,动词)
			学习,吃饭,睡觉,踢球,工作,借钱
	面向对象
		把一切都看成对象(实例)用各种对象之间的关系来描述事物


	什么是类:
		拥有相同属性和行为的对象分为一组,即为一个类
		类是用来描述对象的工具,用类可以创建此类的对象(实例)

类的创建语句:
	class 类名(继承列表):
		'类的文档字符串'
		实例方法的定义
		类变量的定义
		类方法的定义(@classmethod)
		静态方法的定义(@staticmethod)

	作用:
		创建一个类
		类用于描述对象的行为和属性
		类用于创建此类的一个或多个对象(实例)


构造函数
	构造函数的调用表达式:
	语法:
		类名([创建传参列表])
	
	作用:
		创建这个类的实例对象,并返回此实例的引用关系


实例说明:
	1.实例有自己的作用域和名字空间,可以为该类的对象添加实例变量(也叫属性)
	2.实例可以调用类方法和实例方法
	3.实例可以访问变量和实例变量


实例方法 method
	语法:
		class 类名(继承列表)
			def 实例方法名(self,参数1,参数2,...):
			    '文档字符串'
			    语句
	
	作用:
		用于描述一个对象的行为,让此类型的全部对象都拥有相同的行为
	说明:
		1.实例方法实质是函数,是定义在类内的函数
		2.实例方法至少有一个形参,第一个形参代表调用这个方法的实例,
		  一般命名为'self'

实例方法的调用语法:
	实例.实例方法名(调用传参)
	或
	类名.实例方法名(实例,调用传参)

实例属性 atribute(也叫实例变量)
	每个实例对象可以有自己的变量,称为实例变量(也叫属性)

	语法:
		实例.属性名
	赋值规则:
		首次为属性赋值则创建此属性
		再次为属性赋值则修改属性的绑定关系

	作用:
		记录每个对象自身的数据


删除属性 del 语句

	del 对象.实例变量名

	del 语句
		del 变量名		删除变量
		del 列表[整数表达式]	删除列表中的元素
		del 字典[键]		删除字典中的键
		del 对象.属性		删除对象的属性

初始化方法:
	作用:
		对新创建的对象添加属性
	语法:
		class 类名(继承列表):
		  def __init__(self[,形参列表]):
		      语句块
		
		[]代表中的内容可省略
	说明:
		1.初始化方法名必须为 '__init__' 不可改变
		2.初始化方法会在构造函数创建实例后自动调用.且将实例自身通过第一个参数self传入 __init__ 方法
		3.构造函数的实参将通过 __init__ 方法的参数列表传入到 '__init__' 方法中
		4.初始化方法内如果需要 return 语句返回,则只能返回None


析构方法:
	语法:
		class 类名:
			def __del__(self):
			    ....
		
	说明:
		析构方法在对象被销毁时被自动调用
		python建议不要在对象销毁时做任何事情,因为销毁的时间难以确定


预置实例属性
	__dict__ 属性
		__dict__ 属性绑定一个存储此实例自身变量的字典

	__class__ 属性
		此属性用于绑定创建此实例的类

	作用:
		可以借助于此属性来访问创建此实例的类


用于类的函数:
	isinstance(obj,class_or_tuple)  返回这个对象obj是否是某个类的
	对象或某些类中的一个类的对象,如果是则返回True,否则返回False
	type(obj)  返回对象的类型



==============================================================================

类变量
	类变量是类的属性,此属性属于类,不属于此类的实例

	作用:
		通常用来存储该类创建的对象的共有属性

	说明:
		类变量可以通过该类直接访问
		类变量可以通过类的实例直接访问
		类变量可以通过此类的对象的 __class__ 属性间接访问


类的文档字符串
	类内第一个没有赋值给任何变量的字符串为类的文档字符串
	类的文档字符串可以用类的 __doc__ 属性访问


类的 __slots__ 列表
	作用:
		限定一个类创建的实例只能有固定的属性(实例变量)
		不允许对象添加列表以外的属性(实例变量)
		防止用户因错写属性的名称而发生程序错误
	
	说明:
		1.__slots__ 列表绑定一个字符串列表
		2.含有 __slots__ 列表的类所创建的实例对象没有 __dict__ 属性,
		  即此实例不用字典来存储对象的属性(实例变量)

类方法 @classmethod
	类方法是用于描述类的行为的方法,类方法属于类,不属于类的实例

	说明:
		类方法需要使用@classmethod装饰器定义
		类方法至少有一个形参,第一个形参用于绑定类,约定写为'cls'
		类和该类的实例都可以调用类方法
		类方法不能访问此类创建的实例的属性


静态方法 @staticmethod
	静态方法是定义在类内部的函数,此函数的作用域是类的内部

	说明:
		静态方法需要使用 @staticmethod 装饰器定义
		静态方法与普通函数定义相同,不需要传入self实例参数和cls参数
		静态方法只能凭借该类或类创建的实例调用
		静态方法不能访问类变量和实例变量(属性)



实例方法,类方法,静态方法,函数		小结
	不想访问 类内 和 实例内 的变量,用静态方法
	只想访问类内变量,不想访问实例变量,用类方法
	既要访问类变量,也想访问实例变量用实例方法
	函数与静态方法相同,只是静态方法的作用域定义在类内


继承  inheritance  /  派生  derived
	
	什么是继承/派生
		继承是指从已有的类中派生出新的类,新类具有原类的行为,并能扩展新的行为
		派生类就是从一个已有类中衍生成新类,在新类上可以添加新的属性和行为
	作用:
		1.用继承派生机制,可以将一些共有功能加在基类中,实现代码的共享
		2.在不改变基类的代码的基础上改变原有的功能
	名语:
		基类(base class) / 超类(super class) / 父类(father class)
		派生类(derived class) / 子类(child class)

单继承:
	语法:
		class 类名(基类名):
		    语句块
	说明:
		单继承是指由一个基类衍生出新的类
	
继承说明:
	python3任何类都是直接或间接的继承自object
	object类是一切类的超类

类的__base__属性
	__base__属性用来记录此类的基类

python内建的类详见:
	>>>help(__builtins__)

覆盖 override
	覆盖是指在有继承关系的类中,子类中实现了与基类同名的方法,在子类的实例
	调用该方法时,实际调用的是子类中的覆盖版本,这种现象叫做覆盖

子类对象显式调用基类(被覆盖)方法的方式:
	基类名.方法名(实例,实际调用传参)

super 函数
	super(cls, obj) 返回绑定超类的实例(要求obj必须是cls类型的实例)
	super() 返回绑定超类的实例,等同于: super(__class__, 实例方法的第一个参数),必须在方法内调用

	作用:
		借助super() 返回的实例间接调用其父类的覆盖方法

显式调用基类的初始化方法
	当子类中实现了 __init__ 方法,基类的构造方法并不会被调用
	def __init__(self,...)




=============================================================================================

 用于类的函数
	issubclass(cls, cls_or_tuple) 
	判断一个类是否继承自其它类,如果此cls 是class或tuple中的一个派生子类,则返回True,否则返回False


封装 enclosure
	封装是指隐藏类的实现细节,让使用者不关心这些细节
	封装的目的是让使用者通过尽可能少的方法(或属性)操作对象


私有属性和方法
	python类中以双下划线(__)开头,不以双下划线结尾的标识符为私有成员,私有成员或只能用类内的方法进行访问和修改
		以__开头的实例变量有私有属性
		以__开头的方法有私有方法
	

多态 polymorphic
	什么是多态:
		字面意思:多种状态
		多态是指在有继承/派生关系的类中,调用基类对象的方法,实际能调用子类的覆盖方法的现象叫多态

	状态:
		静态(编译时状态)
		动态(运行时状态)
	说明:
		多态调用方法与对象相关,不与类相关
		python的全部对象都只有"运行时状态(动态)",没有"c++语言"里的"编译时状态(静态)"


面向对象的语言的特征
	继承
	封装
	多态


多继承 multiple inheritance
	多继承是指一个子类继承自两个或两个以上的基类

	语法:
	class 类名(基类名1,基类名2,...):
	    ...
	说明:
		1.一个子类同时继承自多个父类,父类中的方法可以同时被继承下来
		2.如果两个父类中有同名的方法,而子类中又没有覆盖此方法时,调用结果难以确定


多继承的问题(缺陷)
	标识符(名字空间)冲突的问题
		要谨慎使用继承
	
多继承的 MRO (Method Resolution Order) 问题
	类的 __mro__ 属性
		此属性用来记录类的方法查找顺序


函数重写
	在自定义类内添加相应的方法,让自定义类创建的实例能像内建对象一样进行内建函数操作

对象转字符串函数:
	repr(obj)	返回一个能代表此对象的表达式字符串,通常
		eval(repr(obj)) == obj	(这个字符串通常是给python解释执行器运行用的)

	str(obj)	通过给定的对象返回一个字符串
			(这个字符串通常是给人阅读的)

对象转字符串函数的重写方法
	repr(obj)	函数的重写方法:
		def __repr__(self):
	
	str(obj)	函数的重写方法:
		def __str__(self):
		
		说明:
			1. str(obj) 函数先查找, obj.__str__()方法,调用此方法并返回
			2. 如果没有__str__()方法时,则返回obj.__repr__()方法的结果并返回
			3. 如果obj.__repr__方法不存在,则调用object类的__repr__实例方法显示
			   <__main__.XXXX object at 0xAABBCCDD>格式的字符串

其他内建函数的重写方法:
	__abs__		abs(obj)	函数
	__len__		len(obj)	函数(必须返回整数)
	__reversed__	reversed(obj)	函数(必须返回可迭代对象)
	__round__	round(obj)	函数

数值转换函数的重写
	__complex__	complex(obj)	函数
	__int__		int(obj)	函数
	__float__	float(obj)	函数
	__bool__	bool(obj)	函数

布尔测试函数重写
	格式:
		__bool__
	作用:
		用于bool(obj) 函数取值
		用于if语句的真值表达式中
		用于while 语句的真值表达式中
	说明:
		1.当自定义的类内有 __bool__(self)方法时,以此方法的返回值作为bool(obj)的返回值
		2.当不存在 __bool__(self) 方法时,bool(x)返回__len__(self)方法的返回值是否为零来测试布尔值
		3.当不存在__len__(self) 方法时,则直接返回True


迭代器(高级)
	什么是迭代器
		可以通过next(it)函数取值的对象就是迭代器
	
迭代器协议
	迭代器协议是指对象能够使用next函数获取下一项数据,在没有下一项数据是触发一个StopIteration异常来终止迭代的约写

	迭代器协议实现方法:
		__next__(self) 方法来实现迭代器协议

	语法形式:
		class MyIterator
		    def __next__(self):
		        迭代器协议
			return 数据

	什么是可迭代对象:
		是指能用iter(obj) 函数返回迭代器的对象(实例)
		可迭代对象内部需要定义__iter__(self) 方法来返回迭代器对象



=========================================================================================================

python应用领域：系统运维
		网络编程（搜索引擎，爬虫，服务器编程）
		科学计算
		人工智能，机器人
		web 开发
		云计算
		大数据及数据库编程
		教育
		游戏，图像处理
		其他

	优点：面向对象（Java，C++，Python，c#，Swift）
	      免费
	      可移植（Windows，Linux，Unix，IOS，安卓）
	      可混合编程（c / c++ / Java / .net）
	      简单易学易用
	      应用领域广泛
	      开源
	缺点：与C/C++相比，执行速度不够快
	      不能封闭源代码

Python官网
	http://www.python.org

python的版本
	python V2.7 （2020年结束维护）
	python V3.5 （当前教学）
	python V3.8 （最新）

python的运行：
	python的解释执行器的类型
		CPython     （C语言开发）
		Jython      （Java语言开发）
		IronPython  （.net开发）
		PyPy	    （Python语言开发）

第一个python程序
	编写：hello.py

	执行python程序
	$ python 文件路径名.py
	例：
	$ python3 绝对路径或相对路径


常用的文件后缀：
	.py              python语言后缀
	.c               C语言
	.cpp/.cc/.cxx	 c++语言后缀
	.java            Java语言后缀


在python交互模式下编写并执行代码
	进入交互模式：
		$ python3 <回车>
	退出交互模式：
		>>>quit（）<回车>
		>>>exit（）<回车>
		或输入：ctrl+d （输入文件结束符）

python的注释
	以#开头，直至行尾
	作用：让注释内容不参加解释执行

	sublime 注释快捷键 ctrl+/

python 程序的组成
	程序是由模块组成
	模块是由数据，函数，类等组成
	函数由语句组成
	语句由表达式组成

python 的核心数据类型
	数字（整形数int，浮点型数float，复数complex，布尔型bool）
	字符串 str，列表 list 等

整形数 int
	整数是不带有小数部分的数字

	整数的字面值表示方式
		十进制表示方式：
		如：
		10
		200
		-100
		八进制表示方式：
		如：
		0o177  （127）
		0o11   （9）
		十六进制表示方式：
		如：
		0x11	（17）
		0xFF	（255）
		0x1a2b
		二进制表示方式：
		如：
		0b111
		0b101

浮点型数 float
	浮点数是带有小数部分的数字（小数部分可以是0）
		小数表示法：
			如：
			3.14     3.1    3.0     3.    0.14    .14 
		科学计数法：
			格式：
			小数  e/E （正负号） 指数
			如：
			6.18E-1		（等同于0.618）    6.18*10（-1）次方
			2.9979e8	（等于299790000.0）

复数complex
	分为两部分：
		实部（real）
		虚部（image）
	虚部是以j或J结尾的数

	字面值：
		1j
		(2J)
		1+2J
		3-4j

布尔型数 bool
	用来表示真和假两张状态的数字
		True表示真（条件满足或成立）
		False表示假（条件不满足或不成立）
	说明：
		True的值为1
		False的值为0


内置对象
	空值None
		None是一个表示不存的特殊对象
	作用：
		用来占位
		变量解除绑定

表达式和运算符
表达式expression
	由一个数字 或 数字和运算符 等组成

	作用：
		通常让计算做一些事情并返回结果
	如：
		1 + 2

运算符：
	算术运算符：
		+	加法
		-	减法
		*	乘法
		/	除法
		//	地板除floordiv
		%	求余
		**	幂运算

	/ 除法
	  除法得到的数是浮点型数，不会丢弃小数部分
	  1 / 3  # 得   0.333333333333333333333
	  8 / 2  # 得   4.0

	// 地板除
	   除得结果去掉小数部分向下取整
	   如：
		7 / 3		 # 得 2.3333333333333333
		7 // 3		 # 得 2
		3.25 // 1.5	 # 得 2.0
	% 求余
	  如：
		7 % 3		 # 得 1
		3.25 % 1.5	 # 得 0.25

	** 幂运算
	   格式：
		x ** y
		意为 x的y次方
	   如：
	   4 ** 2		# 得 16
	   3 ** 4.0		# 得 81.0

运算符得优先级
	**
	*  /  //  %             （优先级相同时自左向右）
	+  -
	实例：
		1 + 3 * 3 ** 2 + 4 // 2
	
括号分组子表达式：
	（）内部的表达式先进行计算

混合类型自动升级
	1 + 2.14 返回类型为浮点型  3.14
	3 + 4.0  返回  7.0

基本输出函数 print
	格式：
	print（要打印的东西）
	多个数据用逗号分隔开


变量  variable
	什么是变量
		变量是关联一个对象的标识符
	
标识符的命名规则；
	必须为字母或下划线开头，后跟字母或下划线或数字
	不能使用python的关键字


	说明：
		python的变量名区分大小写
	合法的标识符（变量名）   举例：
		abc  a1b2  _abc  __Abcd  var
	不合法的标识符：
		1a2b	$ABC	+a	-b	#ABC	@ABC
	python关键字：
		True， False， None， is， del, if, elif ..等
		
赋值语句
	=
	语法：
		变量名 = 表达式
		或
		变量名1 = 变量名2 = 表达式
		或
		变量名1，变量名2 = 序列
	作用：1. 创建一个变量，此变量用来绑定数据对象
	      2. 修改一个变量的绑定关系，让其绑定另一个数据对象

	说明：
		当变量不存在时，创建该变量，同时将变量绑定在这个对象上
		当变量存在时，改变此变量绑定的对象
		一个变量只能绑定一个对象
		两个变量可以同时绑定同一个对象
	示例：
		pi = 3.1415926
		pi2 = pi	# pi变量和pi2变量同时绑定 3.1415926
		x = y = 100	# x变量和y变量同时绑定  100
		x，y = 100，200 # 序列赋值

python中的自动化内存管理
	a = 10000
	b = 20000
	a = a + b	# 释放10000这个对象，a重新绑定30000
	c = a		# c同时绑定在30000上

	a，b = b，a

del 语句：
	作用：
		用于删除变量，同时解除与对象的关联关系，如果可能能释放对象
	语法：
		del 变量名

	在交互模式下查看当前作用域的所有变量
	>>> help('__main__')
	退出键：q

	示例：
		a=10000		# 创建a变量，绑定10000
		print（a）	# 10000
		del a		# 删除了a变量，释放10000这个数据对象
		print（a）	# 出错

自动化内存管理和引用计数
	每个对象都会记录有几个变量绑定（引用）自身，当引用的数量为0时，则此对象将被销毁（释放内存资源），
	此种自动化内存管理的方式叫引用计数

	例：
	a = 10000
	b = a		# 两个变量同时绑定10000这个数据对象
	del a
	del b		# 此时会释放10000这个数据对象

is / is not 运算符
	作用：
		判断两个对象是否是同一个对象，当是同一对象时返回True，否则返回False

	说明：
		is not  返回值与 is 相反
	语法：
		x is y
		x is not y

id（obj）函数
	作用：
		返回一个对象在内存中的地址

小整数对象池
	CPython中，整数 -5 至 256 的数永远存在于小整数池中，不会释放且可重复使用

	示例：
		a = 100
		b = 100
		a is b		# True

复合赋值算术运算符
	运算符：
	y += x		等同于 y = y + x
	y -= x		等同于 y = y - x	
	y *= x		等同于 y = y * x
	y /= x		等同于 y = y / x
	y //= x		等同于 y = y // x
	y %= x		等同于 y = y % x
	y **= x		等同于 y = y ** x

	例：
		x = 100
		x *= 2		# x = 200
		x = 100
		x = x * 2	# x = 200


============================================================================

email : weimz@tedu.cn
魏


比较运算符
	运算符：
		<	小于
		<=	小于等于
		>	大于
		>=	大于等于
		==	等于
		!=	不等于
	语法：
		左表达式 < 右表达式
	说明：
		比较运算返回布尔类型的值
	例:
		20 < 100	# True
		300 >= 20	# True
		1 == 2		# False
		x = 70		
		y = 70
		x != y		#False
		0 <= x <= 100	#True

数值对象的构造（创建）函数
float(obj)
用字符串或数字转换为浮点数，如果不给出实参，则返回0.0
int(x=0,base=10)
用数字或字符串转换为整数，如果不给出实参则返回0
complex(r=0.0,i=0.0)	用数字创建一个复数
bool(x)	用x创建一个布尔值(True/False)

函数调用表达式
	函数名（传参列表）
	说明：
		函数调用时表达式，此表达式一定会返回一个对象的引用关系。
		如果不需要返回值时，通常返回None对象的引用关系

bool(obj)	返回假值的情况：
	None	空值
	False	假值
	0，0.0，0j	所有的数字零
	-----以下后面会讲-----
	''	空字符串
	[]	空列表
	{}	空字典
	()	空元组
	...

内建数值型函数
	abs（x）	取X的绝对值
	round(number,ndigits=0)	对数值进行'四舍五入'，ndigits是小数向右取整的位数，负数表示向左取整
	pow(x,y,z=None)	相当于 x ** y 或 x ** y % z

help()	函数查看帮助
	help(函数名或对象名)
	>>>help(abs)

语句 statements
	语句由一些表达式组成，通常一条语句可以独立执行来完成一部分事情并形成结果
		python建议一条语句写在一行内；
		多条语句写在一行内需要用分号（；）分开
	示例：
		print（“hello”）
		x = 100 + 200
		print(x)
		# 写在一行内为：
		print("hello"); x = 100 + 200; print(x)

显示换行；
	折行符 \ （读作反斜杠）
		折行符必须放在一行的末尾，来示意解释执行器下一行也是本行的语句
	
隐式折行
	所有的括号的内容换行，称为隐式换行
	括号包括()	[]	{}

基本输入函数 input
	作用：
		从标准输入设备上读取一个字符串（末尾的换行符会被删除）
	格式：
		input（‘提示字符串’）
	说明：
		返回输入的字符串（仅python3）
		提示字符串可以为空


基本输出函数 print
	作用：
		将一系列的值以字符形式输出到标准输出设备上，
		默认为终端
	格式：
		print(value, ... sep=' ', end='\n',
		file=sys.stdout, flush=False)
	选项的关键字参数：
		sep：两个值之间的分隔符，默认为一个空格' '
		end: 输出完毕后在末尾自动追加一个字符串，默认为换行符'\n'

if 语句：
	作用：
		让程序根据条件选择性的执行某条语句或某些语句
	语法：
		if 真值表达式1：
			语句块1
		elif 真值表达式2：
			语句块2
		elif 真值表达式3：
			语句块3
		...
		else：
			语句块
	说明：
		elif 可以有0个，1个，或多个
		else 可以有0个或1个

if 语句的真值表达式
	if 100:
	    print('真值')
	等同于：
	if bool(100):
	    print('真值')

	if语句真值表达式返回的对象要用bool（x）取值后再决定执行哪条语句

if 语句的嵌套
	if 语句本身是由多条子句组成的一条复合语句
	if 语句可以作为语句嵌套到另一个语句的内部

条件表达式：
	语法：
		表达式1 if 真值表达式 else 表达式2
	作用：
		根据真值表达式的取值（True/False）
		来决定执行表达式1或表达式2，并返回结果
pass 语句
	作用：
		通常用来填充语法空白
		pass又名空语句
	语法：
		pass

布尔运算
	运算符：
		not	and	or

布尔非操作	not
	语法：
		not x
	作用：
		对表达式x进行布尔取非. 如bool（x）
		为True则返回False，否则返回True
	示例：
		not True	# 返回False
		not False	# 返回True
		month = 10
		if not 1 <= month <=12:
			print('month 不在1~12之间')

布尔与操作	and
	语法：
		x and y
		注：x，y 代表表达式
	作用：
		优先返回假值对象
		当x的布尔值为False时，返回x，否则返回y
	示例：
		True and True	#True
		True and False	#False
		False and True	#False
		False and False	#False
		0 and 0.0	#0
		1.2 and 100	#100

布尔或操作	or
	语法
		x or y
		注：x，y 代表表达式
	作用：
		优先返回真值对象
		当x的布尔值为True时，返回x，否则返回y
	示例：
		True or True	#True
		True or False	#True
		False or True	#True
		False or False	#False
		0 or 0.0	#0.0
		100 or 200	#100

正负号运算符：
		+ （正号）
		- （负号）
	语法：
		+ 表达式
		- 表达式
	说明：
		这是一元运算符（只有一个数据参加运算）
	示例：
		a = 5
		b = -a
		c = +a


==============================================================
字符串 str
	作用：
		用来记录文本（文字）信息
	字符串的表示方式：
		在非注释中，凡是用引号括起来的部分都是字符串
		'	单引号
		"	双引号
		'''	三单引号
		"""	三双引号
	空字符串的字面值表示方法：
		''
		""
		''''''
		""""""
	非空字符串的表示方法：
		'hello'
		"hello"
		'''hello'''
		"""hello"""

单引和双引号的区别：
	单引号内的双引号不算结束符
	双引号内的单引号不算结束符
	示例：
		print("I'm a teacher!")		#I'm a teacher
		print('I am "weimingze"')	#I am "weimingze"

三引号字符串的作用：
	三引号字符串中的换行会自动转换为换行符
	三引号内可以包含单引号和双引号

	示例：
		s = 'welcome to beijing!\nI like python!\nI am studing!'
		print(s)
		s2 = '''welcome to beijing!
		I like python!
		I am studing!'''
		print(s2)

隐式字符串字面值拼接
	s = "I'm a teacher!" 'I am "weimingze"'

用转义序列代表特殊字符
	字符串字面值中，用字符反斜杠(\)
	后跟一些字符代表特殊的一个字符

反斜杠转义字符表：
	\'	单引号(')
	\"	双引号(")
	\\	一个反斜杠
	\n	换行
	\r	返回光标至行首
	\t	水平制表符
	\v	垂直制表符
	\f	换页
	\b	倒退
	\0	空字符，字符值为零
	\xXX	XX为两位十六进制表示的字符
	\uXXXX	XXXX为四个十六进制表示的Unicode16字符
	\UXXXXXXXX	8个十六进制表示的Unicode32字符

ASCII 编码：
	ASCII字符表：
	$ man ascii<回车>

常用的ASCII字符编码：
	字符	十进制	十六进制
	'0'	 48	  0x30
	'A'	 65	  0x41
	'a'	 97	  0x61

Unicode
	统一编码，分为Unicode16和Unicode32

序列的概念
	字符串就是序列

求序列的长度的函数len
	len（x）	返回字符串的字符个数

raw 字符串（原始字符串）
	格式：
		r'字符串内容'
		r"字符串内容"
		r'''字符串内容'''
		r"""字符串内容"""
	作用：
		让转义符号\无效
	示例：
		s = 'C:newfile\test.py'
		print(s)
		print(len(s))
		s = r'C:newfile\test.py'
		print(s)
		print(len(s))

字符串的运算
	+	加号运算符用于拼接字符串
	*	运算符用于生成重复的字符串
	示例：
		s = "ABC" + "DEF"	# s = 'ABCDEF'
		s2 = '123' * 3		# s2 = '123123123'
		s3 = 2 * 'ABC'		# s3 = 'ABCABC'
	注：字符串只能和整数相乘

	+= *= 运算符，与其他赋合赋值运算符规则相同

in / not in 运算符：
	作用：
		用于判断某个字符串是否在
		相当前字符中出现过。如果出现过返回True，否则返回False
	语法：
		对象 in 字符串
	示例：
		s = 'wecome to tarena!'
		'to' in s	#True
		'weimingze' in s	#False
		'e t' in s	# True

字符串的比较运算
	运算符：
		> >= < <= == !=
	规则：
		依次按编码值进行比较，直到最短的字符串结束为止
	示例：
		'A' < 'B'	#True
		'ABC' > 'ABB'	#True
		'ABC' > 'ACB'	#False
		
字符串的索引操作
	python的字符串时不可以改变的字符序列

索引 index
	语法：
		字符串[整数表达式]
	说明：
		python序列都可以用索引来访问序列中的对象
		python序列的正向索引是从0开始的，第二个索引为1，最后一个索引为len(s)-1
		python序列的反向索引是从-1开始的，-1代表最后一个，-2代表倒数第2个，以此类推，第一个是-len（s）
	示例：
		s = 'ABCDE'
		print(s[0])	# A
		print(s[1])	# B
		print(s[4])	# E
		print(s[-1])	# E
		print(s[-5])	# A


==============================================================================

字符串的格式化表达式
	作用：
		生成一定格式的字符串
	语法格式：
		格式字符串 % 参数值
		格式字符串 % （参数值1，参数值2，...）
	说明：
		格式化字符串中以%开头的为占位符，占位符的位置将用参数值替换
	示例：
		fmt = "name:%s,age:%d"
		name = "tarena"
		age = 15
		s = fmt % (name,age)	# s = 'name:tarena,age=15'
		print()

格式化字符串中的占位符和类型码：
	%s	字符串，使用str（obj）转为字符串
	%r	字符串，使用repr（obj）转为字符串
	%c	整数转为字符串，使用chr(i)函数
	%d	十进制整数
	%o	八进制整数
	%x	十六进制整数（字符a-f小写）
	%X	十六进制整数（字符A-F大写）
	%e	指数型浮点数（e小写）	如 2.9e+10
	%E	指数型浮点数（E小写）	如 2.9E+10
	%f，%F	浮点十进制形式
	%g，%G	进制数形式浮点或指数浮点自动转换
	%%	等同于一个%字符

占位符和类型码之间的格式语法：
	% [- + 0 宽度・精度] 类型码
	-	左对齐（默认是右对齐）
	+	显示正号
	0	左侧空白位置补零
	宽度：整个数据输出的宽度
	精度：保留小数点后多少位，默认6位
	示例：
		"%10d" % 123	# '       123'
		"%+10d" % 123	# '      +123'
		"%-10d" % 123	# '123       '
		"%10s" % "ABC"	# '       ABC'
		"%05d" % 123	# '00123'
		"%f" % 3.1415926535897932	# '3.141593'
		"%7.2f" % 3.1415926535897932	# '   3.14'


循环语句：
	while 语句
	for 语句

while 语句
	作用：
		根据一定条件，重复的执行一条语句或多条语句
	语法：
		while 真值表达式：
			语句块1
		else：
			语句块2
	说明：
		1.先执行真值表达式，测试布尔值是否为True或False
		2.如果真值表达式测试值为True，则执行语句1，然后再返回到第1步，重重进行测试
		3.如果真值表达式测试值为False，则执行else子句中的语句块2，然后结束此while语句
		  如果没有else子句，则直接结束此while语句的执行
		注：else子句部分可以省略（同if语句类似）
while语句的注意事项：
	要控制循环真值表达式的值来防止‘死循环’
	通常用真值表达式内的循环变量来控制循环条件
	通常在循环语句块内改变循环变量来控制循环次数和变量走向

while语句的嵌套
	while语句本身是语句，和其他语句一样，可以嵌套放入任何复合语句中

	示例：
		while 真值表达式：
		    ...
		    while 真值表达式2：
		        ...
		    else：
			...
		else：
		    ...
	
break 语句
	作用：
		用于循环语句（while，for）中，用来终止当前循环语句的执行
	说明：
		1.当break语句执行后，此循环语句break之后的语句将不再执行
		2.break语句通常和if语句组合使用
		3.break语句终止循环时，循环语句else子句的语句将不会执行
		4.break语句只能终止当前循环语句的执行，如果有循环嵌套时，不会跳出嵌套的外重循环
		5.brea语句只能在循环语句（while或for语句）内部使用
	
死循环
	死循环是指循环条件一直成立的循环
	死循环通常用break语句来终止循环
	死循环的else子句永远不会执行

示例：
	i=1
	while True：
	    n = int(input("请输入一个数"))
	    if n == i:
	        print("跳出循环")
		break
	print(i,n)
	i += 1




=================================================================================


for 语句
	作用：
		用来遍历可迭代对象的数据元素
可迭代对象是指能依次获取数据元素的对象
  可迭代对象包括:
    字符串str
    ----以下后再才讲----
    列表 list
    元组 tuple
    字典 dict
    集合 set
    ...
      语法:
    for 变量列表 in 可迭代对象:
        语句块1
    else:
        语句块2
说明：
	当循环内部用break语句终止循环时，else子句部分的语句不会执行

range() 函数：
	格式：
		range(stop)	从零开始，每次生成一个整数后加1操作，直到stop为止(不包含stop)
		range(start,stop[,step])从start开始，每次生成一个整数后移动step，直到stop为止(不包含stopo，且step可以是负数)
	详见：
		>> help(range)
	作用：
		用来创建一个生成一系列整数的可迭代对象（也叫整数序列生成器）
	说明：
		range函数调用返回的对象可用于for语句来进行一次迭代取出其中的整数
	示例：
		range(4)	# 0,1,2,3
		range(3,6)	# 3,4,5
		range(1,10,2)	# 1,3,5,7,9
		range(5,0,-2)	# 5,3,1
		range(4,0)	# 空

for 语句嵌套
	
continue 语句
	问题：
		如何让程序不再向下执行，重新开始一次新的循环
	
	continue语句的作用
		用于循环语句中（while，for语句），不再执行本次循环内continue之后的语句，重新开始一次新的循环
	说明：
		1.在while语句中执行continue语句，将会直接跳转到while语句的真值表达式处重新判断循环条件
		2.在for语句中，执行continue语句，将会从可迭代对象中取下一元素绑定变量后再次进行循环

循环总结
	语句：
		while语句
		for语句
			字符串str
			range（）函数返回的对象
		break语句：结束当前循环语句的执行
		continue语句：结束本次循环，重新开始新的循环

列表 list
	列表的定义：
		1.列表是一种容器（通常用来存储计算机的数据对象）
		2.列表是可以被改变的序列
		3.列表是由一系列特定元素组成的，元素与元素之间可能没有任何的关联关系，但他们之间有先后顺序关系
	
	创建空列表的字面值方式
		L = []		# L绑定空列表

	创建空列表的字面值方式
		L = [1,2,3,4]
		L = ['北京','上海','深圳','西安']
		L = [1,'Two',3.14,'四']
		L = [1,2，[3.1,3.2,3.3]，4]
	
	列表的构造函数list
		list()		生成一个空的列表，等同于[]
		list(iterable)	用可迭代对象创建一个列表
	示例：
		L = list()		# L = []
		L = list("hello")	# L = ['h','e','l','l','o']
		L = list(range(5,10,2))	# L = [5,7,9]

列表的运算：
	运算符：
		+	+=	*	*=
		+ 用于拼接列表
			x = [1,2,3]
			y = [4,5,6]
			z = x + y	# [1,2,3,4,5,6]
		+= 用于将右侧的可迭代对象的数据追加到原列表中
			x = [1,2,3]
			x += [4,5,6]	# x = [1,2,3,4,5,6]
			x = [1,2]
			x += "AB"	# x = [1,2,'A','B']
			x = [1,2]
			x += range(3)	# x = [1,2,0,1,2]
		* 用于生成重复的列表
			x = [1,2]*3	# x = [1,2,1,2,1,2]
			x = list("AB")
			x *= 2		# x = ['A','B','A','B']

列表的比较运算：
	运算符：
		< <= > >= == !=
	比较规则：
		同字符串比较规则完全相同
			[1,2,3] < [1,3,2]	#True
			...
		不同：
			[1,'two'] > ['two',1]	#TypeError 出错

列表是可迭代对象：
	L = [2,3,5,7,11]
	for x in L:
	    print(x)

列表的 in / not in 运算符：
	判断一个元素是否存在于列表中，如果存在返回True，否则返回False
	in 和 not in 的返回值相反
	示例：
		x = [1,'two',3,'四']
		3 in x		# True
		4 not in x	# True
		'3' in x	# False


===================================================================


列表的索引操作
	语法：
		列表[整数表达式]
	用法：
		等同于字符串的索引操作（索引分正向索引和反向索引，规则与字符串完全相同）
	列表的索引赋值
		列表是可变的序列，可以通过索引赋值改变列表中的元素
	
列表的切片
	列表[:]
	列表[::]
	列表的切片取值返回一个列表，规则等同于字符串的切片规则

列表的切片赋值：
	作用：
		可以改变原列表的排序，可以插入和修改数据
		可以用切片改变列表对应的元素的值
	语法：
		列表[切片slice] = 可迭代对象
	说明：
		赋值运算符的右侧必须是一个可迭代对象
	示例：
		L = [2,3,4]
		L[0:1] = [1.1,2.2]	# L = [1.1, 2.2, 3, 4]
		L[2:] = [3.3, 4.4, 5.5]

切片赋值注意事项：
	对于步长不等于1的切片赋值，赋值运算符的右侧的可迭代对象
	提供的数据元素的个数一定要等于切片切出的片数

del语句用于删除列表的元素
	语法：
		del 列表[索引]
		del 列表[切片]

python3 中常用的序列相关的函数
 序列有5种：
	str，list，tuple，bytes，bytearray

len(x)	返回序列的长度
max(x)	返回序列的最大值元素
min(x)	返回序列的最小值元素
sum(x)	返回序列中所有元素的和（元素必须是数值类型）
any(x)	真值测试，如果列表中其中一个值为真值则返回True
all(x)	真值测试，如果列表中所有值为真值则返回True

列表中常见的方法(method)
	详见
	>>> help(list)

字符串的文本解析方法split和join
S代表字符串
	S.split（sep=None）  将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时，用空白字符作为分隔符分割
	S.join（iterable）
	用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串


浅拷贝 和 深拷贝
浅拷贝 shallow copy
	浅拷贝是指在复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程

深拷贝


列表推导式 list comprehension
	列表推导式是用可迭代对象生成列表的表达式

	作用：
		用简易方法生成列表
	语法：
		[表达式 for 变量 in 可迭代对象]
		或
		[表达式 for 变量 in 可迭代对象 if 真值表达式]
	说明：
		for in 表达式的if子句可以省略，省略后将对所有生成的对象进行求值处理

	示例：
	# 生成一个数值为1~9的平方列表
	L = [x**2 for x in range(1,10)]

列表推导式的嵌套:
	语法：
		[表达式 
			for 变量1 in 可迭代对象1 if 真值表达式1
				for 变量2 in 可迭代对象2 if 真值表达式2]


==================================================================================


元组	tuple
	元组是不可变的序列，同list一样，元组可以存放任意类型数据的容器

元组的表示方法：
	用小括号()括起来，单个元素括起来后加逗号（，）
	区分单个对象还是元组

创建空元组的字面值：
	t=（）	空元组

创建非空元组的字面值表示：
	t=200，
	t=（20，）
	t=（1,2，3）
	t=100,200,300

函数type(x) 用来返回x对应的类型
元组的错误示例：
	t=（20）	# t 绑定20这个对象，不是元组
	x，y，z = 100,200,300	# 序列赋值
	x，y，z = (100,200,300)	# 序列赋值
	x，y，z = [100,200,300]	# 序列赋值
	x，y，z = 'ABC'		# 序列赋值

元组的构造(创建)函数tuple
	tuple()		生成一个空元组，等同于()
	tuple(iterable)	用可迭代对象生成一个元组

元组的运算：
	+ += * *=
	< <= > >= == !=
	in , not in
	索引[]，切片[:]/[::]

+ 加号用于拼接元组
* 用于生成重复的元组


元组的比较运算：
	规则与列表的比较规则完全相同

in / not in	运算符
	规则写列表的规则完全相同


索引和切片
	索引取值和切片取值的规则与列表完全相同
	元组不支持索引赋值和切片赋值(因为元组不可被改变)

元组的方法：
	T.index(v[,begin[,end]])	返回对应元素的索引下标
	T.count(x)			返回元组中对应的元素个数

序列相关的函数：
	len(x),max(x),min(x),sum(x),any(x),all(x)

构造函数:
	str(x)		创建字符串
	list(iterable)	创建列表
	tuple(iterable)	创建元组


reversed (可迭代对象)	返回反向顺序的可迭代对象
sorted (iterable, key=None, reverse=False)	返回已排序的列表


容器小结：
	字符串	str	# 不可变序列，只能存字符
	列表	list	# 可变的序列，可以存任意数据
	元组	tuple	# 不可变的序列，可以存任意数据


字典 dict
	
什么是字典：
	1.字典是一种可变的容器，可以存储任意类型的数据
	2.字典中的每个数据都是用'键'(key)
	进行索引，而不像序列可以用整数下标来进行索引
	3.字典中的数据没有先后关系，字典的存储是无序的
	4.字典中的数据以键'key'-值(value)对形式进行映射存储
	5.字典的键不能重复，且只能用不可变类型作为字典的键

字典的字面值表示方法：
	字典的表示方式以{}括起来，以冒号(:)
	分隔键-值对，各键-值对之间用逗号分割开
创建空字典的字面值：
	d = {}		# d 绑定空字典

创建非空字典的字面值：
	d = {'name': 'weimingze', 'age': 35}

字典的构造函数dict
	dict()	生成一个字的字典等同于{}
	dict(iterable)	用可迭代对象初始化一个字典
	dict(**kwargs)	用关键字传参形式创建一个字典


字典的键(key)必须为不可变类型
	bool，int，float，complex，str，tuple
	frozenset，bytes(后面讲)

字典的值(value)可以是任意类型

可变的数据类型有四种：
	lsit		列表
	dict		字典
	set		集合
	bytearray	字节数组

字典的基本操作
	字典的键索引
		用[]运算符可以获取字典内'键'对应的值
		也可以用[]运算符来修改'键'对应的值
	键索引的语法：
		字典[键]

添加/修改字典的元素
	语法：
		字典[键] = 值
	说明：
		键不存在时，创建键，并绑定对应的值
		当键存在时，修改键绑定的值

删除字典元素
	del 字典[键]


字典的成员资格判断 in 运算符
	可以用in运算符判断一个键是否存在于字典中，如果存在则返回True，否则返回False
	not in 与 in 结果相反

字典的迭代访问
	字典是可迭代对象，字典只能对键进行迭代访问

可以用于字典的内建函数
	len(x)	返回字典的键值对个数
	max(x)	返回字典的键的最大值
	min(x)	返回字典的键的最小值
	sum(x)	返回字典中所有键的和
	any(x)	真值测试，只对键进行测试，只要有一个键为True，返回True
	all(x)	真值测试，当全部键为真值是，返回True


字典推导式：
	字典推导式是用可迭代对象创建字典的表达式

	语法：
		{键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}
	说明：
		if 子句部分可省略
	

字典	vs	列表
	1. 都是可变对象
	2. 索引方式不同，列表用整数索引，字典用键索引
	3. 字典的插入，删除，修改数据的速度可能会快于列表（重要）
	4. 列表的存储是有序的，字典的存储是无序的


=======================================================================================


集合	set
	集合是可变的容器
	集合内的数据对象都是唯一的（不能重复多次的）
	集合是无序的存储结构，集合中的数据没有先后关系
	集合内的元素必须是不可变对象
	集合是可迭代对象
	集合是相当于只有键没有值得字典（键则是集合的数据）

创建空集合
	s = set()

创建非空集合
	s = {1,2,3}
	s = {3.14，True，(1970.1.1)，"hello"}


集合的构造函数 set
	set()	创建一个空的集合对象(不能用{}创建空集合)
	set(iterable)	用可迭代对象创建一个新的集合对象


集合的运算：
	交集，并集，补集，子集，超集

	& 生成两个集合的交集
	| 生成两个集合的并集
	- 生成两个集合的补集
	^ 生成两个集合的对称补集
	> 判断一个集合是另一个集合的超集
	< 判断一个集合是另一个集合的子集

	== !=	集合相同/不同

in , not in 运算符
	等同于字典in，not in
	作于集合中，判断某个值是否存在于集合中

集合和字典的优点：
	in / not in 运算符得判断速度快些

能用于集合的函数：
	
	len(x),max(x),min(x),sum(x),any(x),all(x)

python3 中常用的集合方法
	

集合推导式
	集合推导式是用可迭代对象生成集合的表达式

	语法：
		{表达式 for 变量 in 可迭代对象 [if 真值表达式]}

集合推导式可以嵌套：
	语法同列表推导式一致！

固定集合  frozenset
	固定集合是不可变得，无序的，含有唯一元素的集合
	作用：
		固定集合可以作为字典的键，还可以作为集合的值

	固定集合的构造函数：
		frozenset()	创建一个空的固定集合
		frozenset(iterable)	用可迭代对象创建固定集合

固定集合的运算：
	& 交集，   | 并集，    - 补集，    ^ 对称补集
	<  <=  >  >=  ==  !=
	in / not in
	(以上运算符和集合set中的用法完全一致)

固定集合的方法
	相当于集合的全部方法去掉修改集合的方法
















1.数据类型：
	数值类型：
		int，float，complex，bool
	容器：
		不可变的容器
			str，tuple，frozenset，bytes
		可变的容器
			list，dict，set，bytearray

2.值：
	None，False，True

3.运算符：
	算术运算符：
		+  -  *  /  //  %  **
	比较运算符：
		<  <=  >  >=  ==  !=
		in / not in
		is, is not
	布尔运算：
		not，and，or
	+(正号)  -(负号)
	&  |  ^
	[]  (索引,切片,键索引)

4.表达式：
	1
	1 + 2
	max(1,2,3)		# 函数调用是表达式
	x if x > y else y,	# 条件表达式
	三种推导式：
		列表，字典，集合推导式(三种)

5.语句:
	表达式语句:
		所有的表达式都可以单独写在一行,形成一个语句
			例:print("hello world!")
	赋值语句:
		a = 100
		a = b = c = 100
		x,y = 100,200
		a[0] = 100
		dict['name']='tarena'
	del 语句
	if 语句
	while 语句
	for 语句
	break 语句
	continue 语句
	pass 语句

6.内建函数:
	len(x),max(x),min(x),sum(x),any(x),all(x)
	构造函数(用来创建同类型的数据对象)
		bool(x),int(x),float(x),complex(x),
		list(x),tuple(x),str(x),dict(x),
		set(x),frozenset(x)
	abs(x)
	round(x)
	pow(x,y,z=None)

	bin(x),oct(x),hex(x)
	chr(x),ord(x)
	range(start,stop,step)
	input(x),print(x)

	>>> help(__builtins__)


函数 function
	什么是函数：
		函数是可以重复执行的语句块，可以重复调用
	作用：
		1.用于封装语句块,提高代码的重用性
		2.定义用户级别的函数

	语法:
		def 函数名(形参列表):
		    语句块
	说明:
		1.函数的名字就是语句块的名称
		2.函数名的命名规则与变量名相同(函数名必须是标识符)
		3.函数名是一个变量(不要轻易对其赋值)
		4.函数有自己的名字空间,在函数外部不可以访问函数内部的变量,
		  在函数内可以访问函数外部的变量,但不能修改此变量
		5.函数如果不需要传入参数,形参列表可以为空
		6.语句部分不能为空,如果为空需要填充pass

函数调用
	函数名(实际调用传递参数)
		注:实际调用传递参数,以后简称实参

	说明:
		1.函数调用是一个表达式
		2.如果函数内部没有 return 语句,函数调用完毕后返回 None 对象
		3.如果函数需要返回其他的对象需要用到 return 语句

return 语句
	语法:
		return [表达式]
		注: [] 代表可省略
	作用:
		用于函数中,结束当前函数的执行,返回到调用该函数的地方,同时返回一个对象的引用关系

	return 语句说明
		1.return 语句后跟的表达式可以省略,省略后相当于renturn None
		2.如果函数内没有return语句,则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)

==============================================================================================================

函数的参数传递
	传递方式：
		位置传参
			序列传参
		关键字传参
			字典关键字传参

位置传参：
	实际参数(实参)的对应关系与形式参数(形参)
	的对应关系是按位置来依次对应的

序列传参:
	序列传参是指在函数调用过程中,用 *
	将序列拆解后按位置进行传递的传参方式

	说明:
		序列传参时,序列拆解的位置将与形参一一对应
		序列的位置信息对应相应的形参位置

关键字传参:
	关键字传参是指传参时,按照形参的名称给形参赋值
	实参和形参按形参名进行匹配

字典关键字传参:
	是指实参为字典,将字典用 '**' 
	拆解后再进行关键字传参的传参方式

	说明:
		字典的键名和形参名必须一致
		字典的键名必须为字符串(标识符)
		字典的键名要在形参中存在

函数的综合传参:
	函数的传参方式在能确定形参能唯一匹配到相应实参的情况下可以任意组合

	说明:
		位置传参(序列传参)要在关键字传参(字典关键字传参)的左侧




----------函数形参的定义----------

函数的缺省参数:
	语法:
		def 函数名(形参名=默认实参1,形参名2=默认实参2,...):
		    语句块
	说明:
		缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其右侧的所有参数都必须有缺省参数

		如:
			def fe(a,b=10,c):	# 错误
			    pass

函数形参的定义方式:
	1.位置形参
	2.星号元组形参
	3.命名关键字形参
	4.双星号字典形参

位置形参:
	语法:
		def 函数名(形参名1,形参名2,...):
		    语句块

星号元组形参:
	语法:
		def 函数名(*元组形参名):
		    语句块
	作用:
		收集多余的位置传参
	
命名关键字形参:
	语法:
		def 函数名(*,命名关键字形参):
		    语句块
		或
		def 函数名(*args,命名关键字形参):
		    语句块
	作用:
		强制所有的参数都必须用关键字传参或字典关键字传参


双星号字典形参:
	语法:
		def 函数名(**字典形参名):
		    语句块
	作用:
		收集多余的关键字传参
	说明:
		字典形参名通常命名为'kwargs'

函数的参数说明:
	位置形参,缺省参数,星号元组形参,双星号字典形参可以混合使用

	函数形参自左至右的顺序为:
		位置形参
		星号元组形参
		命名关键字形参
		双星号字典形参

函数的不定长参数:
	星号元组形参,双星号字典形参

	说明:
		可以接受任意的位置传参和关键字传参
	
全局变量和局部变量
	局部变量: local variable
		1.定义在函数内部的变量称为局部变量(
		  函数的形参也是局部变量)
		2.局部变量只能在函数内部使用
		3.局部变量在函数调用时才能够被创建,在
		  函数调用之后会自动销毁

	全局变量: global variable
		定义在函数外部,模块内部的变量称为全局变量
		全局变量所有函数都可以直接访问(但
		函数内不能将其直接赋值)

====================================================================================================

globals() /locals()函数:
	globals()	返回当前全局作用域内变量的字典
	locals()	返回当前局部作用域内变量的字典


函数变量
	函数名是变量,它在def 语句创建函数时绑定一个函数




一个函数 可以作为另一个函数的实参传递



函数可以作为另一个函数的返回值


函数的嵌套定义
	函数嵌套定义是指一个函数里用def 语句来创建其他的函数的情况

python的作用域
	作用域也叫名字空间,是访问变量时查找变量名的范围空间

python的四个作用域:
	作用域			英文解释			英文缩写
局部作用域(函数内)		Local(function)			 L
外部嵌套函数作用域		Enclosing function locals	 E
函数定义所在模块(文件)作用域	Global(module)			 G
python内建模块的作用域		Builtin(Python)			 B


变量名的查找规则
	在变量访问时,先查找本地变量,然后是包裹此函数外部的函数内部的变量,之后是全局变量,最后是内建变量


global语句
	作用:
		1.告诉解释执行器global语句声明的一个或多个变量,这些变量的作用域为模块级的作用域,也称作全局变量
		2.全局声明(global)
		将赋值语句操作的变量映射到模块文件内部的作用域

	语法:
		global 变量1,变量2,...
	
	说明:
		1.全局变量如果要在函数内部被赋值,则必须经过全局声明(否则会被认为是创建局部变量)
		2.全局变量在函数内部不经过声明就可以直接访问(变量已经存在并关联一个对象)
		3.不能先声明局部变量,再用global声明为全局变量,此做法不符合规则
		4.global变量列表里的变量名不能出现在此作用域的形参列表里


nonlocal 语句
	作用:
		告诉解释执行器,nonlocal声明的变量不是局部变量,也不是全局变量,它是外部嵌套函数内的变量
	
	语法:
		nonlocal 变量名1,变量名2,...
	
	说明:
		1.nonlocal 语句只能在被嵌套的函数内部进行使用
		2.访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
		3.当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近的一层变量进行操作
		4.nonlocal语句的变量列表里的变量名,不能出现在此函数的参数列表中


lambda 表达式(又称匿名函数)
	作用:
		创建一个匿名函数对象
		同def 类似,但不提供函数名
	格式:
		lambda[参数1,参数2,...]: 表达式
	
	说明:
		1.lambda只是一个表达式,它用来创建一个函数对象
		2.当lambda表达式调用时,先执行冒号(:)后的
		  表达式,并返回表达式的结果的引用关系
		3.lambda表达式创建的函数只能包含一条表达式
		4.lambda比函数简单且可以随时创建和销毁,有利于减少程序的偶合度

eval() / exec() 函数

	eval(source,globals=None,local=None)
	把一个字符串 srouce
	当成一个表达式来执行,返回表达式执行的结果

	exec(source,globals=None,locals=None)
	把一个字符串source当成程序来执行


====================================================================================

函数式编程
	函数式编程是指用一系列函数解决问题
	
	好处：
		1.用每一个函数完成细小的功能,一系列函数的任意组合可以完成大问题
		2.函数仅接受输入并产生输出,不包含任何能影响输出的内部状态
		
	函数的可重入性
		如果一个函数的输入参数一定,则返回结果必须一定的函数称为可重入函数       

	# 不可重入函数:
		y=200
		def myadd(x):
		    return x + y
		print(myadd(10))   # 210
		y = 300
		print(myadd(10))   # 310

	函数式编程的要求:
		def 创建的函数最好不要访问局部作用域以外的变量,
		这样可以保证结果的唯一性(可重入性)

	
高阶函数 High Order Function
	什么是高阶函数:
		满足下列条件之一的即为高阶函数
			1.函数接受一个或多个函数作用参数传入
			2.函数返回一个函数
			
python内建的高阶函数:
	map,filter,sorted
	
map函数:
	格式:
		map(func, *iterables)
	说明:
		用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象,
		当最短的一个可迭代对象不再提供数据时此可迭代对象生成结束

filter函数:
	filter(function,iterable)
	筛选可迭代对象iterable中的数据,返回一个可迭代器对象，此可迭代对象
	将对iterable进行筛选.函数function 将对iterable中的每个元素进行求值，
	返回False则将此数据丢弃，返回True，则保留此数据

sorted函数
	作用:
		将原可迭代对象的数据进行排序，生成排序后的列表
	格式:
		sorted(iterable, key=None, reverse=False)
	说明:
		iterable可迭代对象
		key函数是用来提供一个值,这个值将作为排序的依据
		reverse标志用来设置是否降序排序

递归函数 recursion
	函数直接或间接的调用自身

	递归说明:
		递归一定要控制递归的层数,当符合一定条件时要终止递归
		几乎所有的递归都能用while循环来代替

	递归的优缺点:
		优点:
			递归把问题简单化,让思路更为清晰,代码更简洁
		缺点:
			递归因系统环境影响大,当递归深度太大时,可能会得不到不可预知的结果

	递归的两个阶段
		递推阶段:
			从原问题出发按递归公式递推从未知到已知,最终达到递归的终止条件
		回归阶段:
			按递归终止条件求出结果,逆向逐步代入递归公式,回归到原问题求解

	
闭包 closure
	什么是闭包:
		闭包是指引用了此函数外部变量的函数

	说明:
		在本质上,闭包是将内部嵌套函数和函数外部的执行环境绑定在一起的对象

	闭包必须满足三个条件:
		1.必须有一个内嵌函数
		2.内嵌函数必须引用外部函数中的变量
		3.外部函数返回值必须是内嵌函数


===================================================================================================

装饰器 decorators(专业提高篇)
	装饰器是一个函数,主要作用是用来包装另一个函数或类(后面讲)

	装饰的目的是在不改变原函数名(或类名)的情况下,改变被包装对象的行为

函数装饰器
	函数装饰器指装饰器传入的是一个函数,返回的也是一个函数

	语法:
		def 装饰器函数名(参数):
		    语句块
		    return 函数对象
	
		@装饰器函数名<换行>
		def 函数名(形参列表):
		    语句块
		
函数的文档字符串
	函数内第一次未被赋值给任何变量的字符串是此函数的文档字符串

	语法:
		def 函数名(参数列表):
		    '函数文档字符串'
		    函数语句块

	说明:
		1.文档字符串通常用来说明本函数的功能和使用方法
		2.在交互模式下输入:help(函数名)
		  可以查看函数的'文档字符串'
		3.函数的文档字符串绑定在函数的 __doc__ 属性上

函数的 __doc__ 属性
	用于绑定函数的文档字符串

函数定义语句(def 语句)的完整语法:
	[@装饰器1]
	[@装饰器2]
	[...]
	def 函数名([位置形参],[*元组形参],[命名关键字形参],[**字典形参]):
	    '''文档字符串'''
	    语句块

	注:[]代表其内部可以省略


模块  Module
	什么是模块:
		模块是一个包含有一系列数据,函数,类等组成的程序组
		模块是一个文件,模块文件名通常以.py结尾


	作用:
		让一些相关的数据,函数,类等有逻辑的组织在一起,使逻辑结构更加清晰
		模块中的数据,函数,类等可提供给其他模块或程序使用


	模块的分类:
		内建模块(builtins)在解析器的内可以直接使用
		标准库模块,安装python时已安装且可以直接使用
		第三方模块(通常开源),需要自己安装
		用户自己编写的模块(可UI作为其他人的第三方模块)

模块的导入语句 
import 语句
	语法:
		import 模块名1 [as 模块新名1],模块名2 [as 模块新名2],...

	作用:
		将某模块整体导入到当前模块中

	用法:
		模块名.属性名
		或
		模块名.函数属性名(实参传参)

	dir(obj) 函数返回所有属性的字符串列表
	help(obj) 函数可以查看模块的相关文档字符串

from import
	语法:
		from 模块名 import 模块属性名1 [as 属性新名1],
		模块属性名2 [as 属性新名2], ...
	作用:
		将某模块的一个或多个属性导入到当前模块的作用域
	
from import * 语句
	语法:
		from 模块名 import *
	作用:
		将某模块的所有属性导入到当前模块

dir 函数:
	dir([对象])	返回一个字符串的列表

	说明:
		如果没有给参数调用,则返回当前作用域内的所有变量的列表
		如果给定一个对象作为参数,则返回这个对象的所有的变量的列表
			1) 对于一个模块,返回这个模块的全部属性
			2) 对于一个类,返回这个类的所有变量,并递归基类对象的所有变量
			3) 对于其它的对象,返回所有变量类变量和基类变量


内建模块

math 模块
	模块名 math



时间模块 time
	

系统模块 sys
	



============================================================================================


自定义模块并导入
	
	注意事项:
		自定义模块的文件要求以.py结尾,文件名必须是标识符的规则

导入 import 语句等  搜索块的路径顺序
	搜索顺序:
		1.搜索程序运行时的路径(当前路径)
		2.sys,path提供的路径
		   sys.path是一个列表,里面放的都是模块的搜索路径
		3.搜索内建模块


模块的加载过程:
	1.在模块导入时,模块的所有语句都会执行
	2.如果一个模块已经导入,则再次导入时不会重新执行模块内的语句


模块的重新加载
	import mymod
	import imp
	imp.reload(mymod)	# 重新加载mymod


模块以导入和执行的过程:
	1.先搜索相关的路径,找到模块名.py
	2.判断是否有此模块对应的.pyc文件。如果.pyc比.py文件新,则直接加载.pyc文件
	3.否则用模块.py,文件生成.pyc,并加载执行

pyc python的编译
		     编译		解释执行
	mymod.py  -------->  mymod.pyc  -------->  python3

模块的文档字符串:
	模块内第一个没有赋值给任何变量的字符串称为模块的文档字符串

	模块的 __doc__ 属性
		此属性用于绑定模块的文档字符串

	模块的 __file__ 属性
		此属性用于记录模块对应的文件路径名

	模块的 __name__ 属性
		__name__ 属性 用来记录模块自身名字

		作用:
			1.记录模块名
			2.用来判断是否为主模块
		说明:
			当模块为主模块(也就是第一个运行的模块时)运行时,
			__name__绑定'__main__'
			当此模块不是主模块时,而是被其他模块导入时,此时
			__name__绑定模块名

模块的 __all__ 列表
	模块中的 __all__ 列表是一个用来存放可导出属性的字符串列表

	作用:
		当用 from xxx import *
		语句导入时,只导入__all__列表内的属性

模块的隐藏属性
	模块中以'_'开头的属性,在from xxx import *
	导入时,将不被导入,通常称这些属性为隐藏属性

随机模块 random
	模块名 random
		作用:
			用于模拟或生成随机输出的模块

包(模块包) package
	包的定义
		包是将模块以文件夹的组织形式进行分组管理的管理方法
	作用:
		将一系列模块进行分类管理,有利于防止命名冲突
		可以在需要时加载一个或部分模块则不是全部模块

__init__.py 文件
	__init__.py是常规包内必须存在的文件
	__init__.py会在包加载时自动调用

	作用:
		1.编写此包的内容
		2.在内部填写文档字符串
		3.在__init__.py文件内可以加载此包所依赖的一些其他模块

包的导入
	同模块的导入规则
	# import 语句
	import 包名 [as 包新名]
	import 包名.模块名 [as 模块新名]
	import 包名.子包名.模块名 [as 模块新名]

	# from import语句
	from 包名 import 模块名 [as 模块新名]
	from 包名.子包名 import 模块名 [as 模块新名]
	from 包名.子包名.模块名 import 属性名 [as 属性新名]

	# from import *语句
	from 包名 import *
	from 包名
	...


导入包时的索引路径顺序:
	1.搜索程序的当前路径
	2.sys.path 提供的路径


__init__.py内的 __all__ 列表
	作用:
		用来记录此包中有哪些子名或模块在用from import *语句
		时被导入
	说明:
		__all__列表只对 from xxx improt *语句起作用
	

包的相对导入:
	包的相对导入是指包内模块的相互导入

	语法:
		from 相对路径包或模块 import 属性或模块名
		from 相对路径包或模块 import *
	相对路径
		. 代表当前目录
		.. 代表上一级目录
		... 代表上二级目录
		.... 以此类推

		注:相对导入时不能超出包的外部



==============================================================================================

异常(基础) except
	什么是错误
		错误是指由于逻辑或语法等导致一个程序已无法正常执行的问题
	
	什么是异常
		异常是程序出错时标识的一种状态
		当异常发生时,程序不会再向下执行,而转去调用此函数的地方待处理此异常并恢复为正常状态
	
	异常作用:
		用作信号,通知上层调用者有错误产生需要处理

try 语句:
	两种语法:
		try-except语句
		try-finally语句
	
	try-except语句语法:
		try:
		    可能触发异常的语句
		except 错误类型1 [as 变量1]:
		    异常处理语句1
		except 错误类型2 [as 变量2]:
		    异常处理语句2
		except (错误类型3,错误类型4,...) [as 变量3]:
		    异常处理语句3
		...
		except:
		    异常处理语句(其他)
		else:
		    未发生异常语句
		finlly:
		    最终语句
	作用:
		尝试捕获异常,将程序由异常状态转为正常状态并正常执行

	try-except语句说明:
		1.as 子句是用于绑定错误对象的变量,可以省略
		2.except 子句可以有一个或多个,但至少要有一个
		3.else子句最多只能有一个,也可以省略不写
		4.finally子句最多只能有一个,也可以省略不写
		5.else子句的语句将再次try语句没有发生异常时被执行
		6.finally子句的语句在任何情况下都会被执行

python中全部的错误类型
	参见文档
	
try-finally语句
	语句:
		try:
		    可能触发异常的语句:
		finally:
		    最终语句
	
	说明:
		1.finally 子句不可以省略
		2.一定不存在except子句
	作用:
		通常用try-finally语句来做触发异常时必须要处理的事情
		无论异常是否发生,finally子句都会被执行
	注意:
		try-finally 语句不会改变程序的(正常/异常)状态

raise语句
	作用:
		触发一个错误,让程序进入异常状态
	语法:
		raise 异常类型
		或
		raise 异常对象

assert 语句(断言语句)
	语法:
		assert 真值表达式,错误数据(通常是字符串)
	作用:
		当真值表达式为False时,用错误数据创建一个AssertionError
		类型的错误,并进入异常状态
	等同于:
		if 真值表达式 == False
		    raise AssertionError(错误数据)

小结:
	异常处理语句(四条):
		try-except 语句:
			用于接收异常通知,捕获异常
		try-finally 语句:
			执行必须要执行的语句
		raise 语句:
			发送异常通知,并进入异常状态
		assert 语句:
			根据条件选择性的发送AssertionError类型的异常通知


为什么要异常处理机制:
	在程序调用层数较深时,向主调函数传递错误信息需要层层return
	返回比较麻烦,用异常处理机制可以较简单的传送错误信息


=======================================================================================
迭代器 Iterator
	
	什么是迭代器
		迭代器是访问可迭代对象的工具
		迭代器是指用iter(obj)函数返回的对象(实例)
		迭代器可以用next(it)函数获取可迭代对象的数据

	迭代器函数 iter和 next
		iter(iterable)从可迭代对象中返回一个迭代器,iterable必须是能提供一个迭代器的对象
		next(iterator)从迭代器iterator中获取下一个记录,如果无法获取下一条记录,则触发StopIteration异常

		说明:
			迭代器只能向前取值,不会后退
			用iter函数可以返回一个可迭代对象的迭代器
		作用:
			迭代器对象能用next函数获取下一个元素


生成器 Generator (python 2.5 及以后)
 什么是生成器:
	生成器是能够动态提供数据的对象,生成器对象也是可迭代对象(实例)

生成器有两种:
	1.生成器函数
	2.生成器表达式

生成器函数的定义
	含有yield语句的函数是生成器函数,此函数被调用将返回一个生成器对象
	yield 翻译为(产生或生成)

yield 语句
	语法:
		yield 表达式
	说明:
		yield 用于 def 函数中,目的是将此函数作用生成器函数使用
		yield 用来生成数据,供迭代器的next(it)函数使用
 
生成器函数说明:
	生成器函数的调用将返回一个生成器对象,生成器对象是一个可迭代对象
	在生成器函数调用return会触发一个StopIteration异常



生成器表达式:
	语法:
		(表达式 for 变量 in 可迭代对象 [if 真值表达式 ])

	说明:
		if 子句可以省略
	作用:
		用推导式的形式创建一个新的生成器



迭代工具函数
	迭代工具函数的作用是生成一个个性化的可迭代对象

	zip(iter1[,iter2[,...]]) 返回一个zip对象,此对象用于生成元素,此元组的个数由最小的可迭代对象决定

	enumerate(iterable[,start])
	生成带索引的枚举对象,返回迭代类型为索引-值对(index-value对),默认索引从零开始,也可以用start指定


字节串和字节数组
字节串 bytes (也叫字节序列)
	作用:
		存储以字节为单位的数据
		字节串是不可变的字节序列
	
字节:
	字节是由8个位 (bit) 组成的数据单位,是计算进行数据管理的单位
	字节是用 0 ~ 255 范围内的整数表示的


创建空字节串的字面值
	B = b''
	B = b""
	B = b''''''
	B = b""""""
创建非空字节串的字面值
	B = b'ABCD'
	B = b"ABCD"
	B = b'\x41\x42'

字节串的构造函数 bytes
	bytes() 生成一个字的字节串 等同于 b''
	bytes(整数可迭代对象)	# 用可迭代对象初始化一个字节串
	bytes(整数n)	生成n个值为0的字节串
	bytes(字符串, encoding='utf-8')
	用字符串转为编码生成一个字节串


bytes 的运算
	+  +=  *  *=
	<  <=  >  >=  ==  !=
	in / not in
	索引和切片

	len(x)
	max(x)
	min(x)
	sum(x)
	any(x)
	all(x)


bytes 和 str 区别
	bytes 存储字节(通常值 range(0,256))
	str 存储 unicode 字符( 通常值在0 ~ 65535)

bytes 与 str 的转换
	编码(encode)
	str ---------------> bytes
		b = s.encode(encoding='utf-8')

		解码(decode)
	bytes --------------> str
		s = b.decode(encoding='utf-8')


字节数组 bytearray
	可变的字节序列

字节数组的构造函数: bytearray
	bytearray() 	创建空的字节数组
	bytearray(整数) 	用可迭代对象初始化一个字节数组
	bytearray(整型可迭代对象) 	生成n个值为0的字节数组
	bytearray(字符串, encoding='utf-8') 	用字符串的转换编码生成一个字节数组
	用字符串的转换编码生成一个字节数组

	
bytearray 的运算
	+  +=  *  *=
	<  <=  >  >=  ==  !=
	in / not in
	索引和切片
	(字节数组支持索引和切片的赋值操作,规则同列表的索引和切片赋值规则)


bytearray的方法:
	BA.clear()清空
	BA.append(n)追加一个字节(n为0 ~ 255的整数)
	BA.remove(value)删除第一个出现的字节,如果没有出现,则触发ValueError错误
	BA.reverse() 字节顺序反转
	BA.decode(encoding='utf-8')	# 解码为字符串
	BA.find(sub[,start[,end]])	# 查找 sub




=====================================================================================
文件 File
	文件是用于数据存储的单位
	文件通常用来长期存储数据
	文件中的数据是以字节为单位进行顺序存储的

文件的操作流程：
	1.打开文件
	2.读/写文件
	3.关闭文件
	注:任何的操作系统,一个应用程序同时打开文件的数量有最大数限制

文件的打开函数
	open(file,mode='rt') 
	用于打开一个文件,返回此文件流对象,如果打开文件失败,则会触发OSError错误

文件的关闭方法:
	F.close()	# 关闭文件,释放系统资源

文本文件操作
	操作模式:
		't'
	说明:
		1.默认文件中存储的都为字符数据,在读写过程中会自动进行编解码操作,
		2.文本文件以行为单位进行分隔,在python内部统一用'\n'作为换行符进行分隔
		3.对文本文件的读写操作需要用字符串(str)进行数据操作
		
	各操作系统的换行符
		Linux换行符: '\n'
		Windows 换行符: '\r\n'
		新的Mac OS 换行符: '\n'
		旧的Macintosh 换行符: '\r'(已不用了)

文件流对象是可迭代对象,迭代过程中将以换行符'\n'作为分隔符


标准输入输出文件:
	sys.stdin	标准输入文件
				ctrl+d 输入文件结束符
	sys.sdout	标准输出文件
	sys.stderr	标准错误输出文件
	注:标准文件不需要打开和关闭就可以使用


二进制文件操作:
	二进制文件操作模式字符: 'b'
	
	默认的文件中存储的是以字节为单位数据,通常有人为规定的格式
	二进制文件操作需要用字节串进行读写

F.read()/F.readline()/F.readlines() 返回类型
	对于文本文件,F.read()等函数返回为字符串(str)
	对于二进制文件,F.read()等函数返回为字节串(bytes)


F.write() 对于二进制文件与需要用字节串进行操作


F.tell方法:
	作用:
		返回当前的读写位置(从文件头以字节为单位)
	
F.seek方法:
	作用:
		设置读写位置

	F.seek(偏移量,whence=相对位置)
	偏移量
		大于0的数代表向文件末尾方向移动的字节数
		小于0的数代表向文件头方向中移动的字节数
	相对位置
		0 代表从文件头开始偏移
		1 代表从文件当前读写位置开始偏移
		2 代表从文件尾开始偏移

汉字编码(只讲两种)
	国标系列:
		GB18030 (二字节或四字节编码,共27533个字)
		  GBK     (二字节编码,共21003个字)
		    GB2312  (二字节编码,共6763个汉字)
		(Windows常用)
	国际标准: UNICODE <---> UTF-8
		(Linux / Mac OS X / IOS / Android 等常用)

	问题:
		十个汉字占多少字节
		UTF-8		30个字节


python 编码字符串:
	'gb2312'
	'gbk'
	'gb18030'
	'utf-8'
	'ascii'
	...
	以上字符串用于encode和decode中

编码注释:
	在python源文件的第一行或第二行写入如下内容:
		# -*- coding:gbk -*-
		# 设置源文件编码格式为gbk
		或
		# -*- coding:utf-8 -*-
		# 设置源文件编码格式为utf-8
	作用:
		告诉解释执行器,此前文件的编码是什么?

=================================================================


面向过程编程:
	函数做单位


面向对象编程 Ojbect-Oriented Programing
	什么是对象:
		对象是指现实中的物体或实体

	对象有什么特征:
		对象有很多属性(名词,形容词)
			姓名,年龄,性别
		对象有很多行为(动作,动词)
			学习,吃饭,睡觉,踢球,工作,借钱
	面向对象
		把一切都看成对象(实例)用各种对象之间的关系来描述事物


	什么是类:
		拥有相同属性和行为的对象分为一组,即为一个类
		类是用来描述对象的工具,用类可以创建此类的对象(实例)

类的创建语句:
	class 类名(继承列表):
		'类的文档字符串'
		实例方法的定义
		类变量的定义
		类方法的定义(@classmethod)
		静态方法的定义(@staticmethod)

	作用:
		创建一个类
		类用于描述对象的行为和属性
		类用于创建此类的一个或多个对象(实例)


构造函数
	构造函数的调用表达式:
	语法:
		类名([创建传参列表])
	
	作用:
		创建这个类的实例对象,并返回此实例的引用关系


实例说明:
	1.实例有自己的作用域和名字空间,可以为该类的对象添加实例变量(也叫属性)
	2.实例可以调用类方法和实例方法
	3.实例可以访问变量和实例变量


实例方法 method
	语法:
		class 类名(继承列表)
			def 实例方法名(self,参数1,参数2,...):
			    '文档字符串'
			    语句
	
	作用:
		用于描述一个对象的行为,让此类型的全部对象都拥有相同的行为
	说明:
		1.实例方法实质是函数,是定义在类内的函数
		2.实例方法至少有一个形参,第一个形参代表调用这个方法的实例,
		  一般命名为'self'

实例方法的调用语法:
	实例.实例方法名(调用传参)
	或
	类名.实例方法名(实例,调用传参)

实例属性 atribute(也叫实例变量)
	每个实例对象可以有自己的变量,称为实例变量(也叫属性)

	语法:
		实例.属性名
	赋值规则:
		首次为属性赋值则创建此属性
		再次为属性赋值则修改属性的绑定关系

	作用:
		记录每个对象自身的数据


删除属性 del 语句

	del 对象.实例变量名

	del 语句
		del 变量名		删除变量
		del 列表[整数表达式]	删除列表中的元素
		del 字典[键]		删除字典中的键
		del 对象.属性		删除对象的属性

初始化方法:
	作用:
		对新创建的对象添加属性
	语法:
		class 类名(继承列表):
		  def __init__(self[,形参列表]):
		      语句块
		
		[]代表中的内容可省略
	说明:
		1.初始化方法名必须为 '__init__' 不可改变
		2.初始化方法会在构造函数创建实例后自动调用.且将实例自身通过第一个参数self传入 __init__ 方法
		3.构造函数的实参将通过 __init__ 方法的参数列表传入到 '__init__' 方法中
		4.初始化方法内如果需要 return 语句返回,则只能返回None


析构方法:
	语法:
		class 类名:
			def __del__(self):
			    ....
		
	说明:
		析构方法在对象被销毁时被自动调用
		python建议不要在对象销毁时做任何事情,因为销毁的时间难以确定


预置实例属性
	__dict__ 属性
		__dict__ 属性绑定一个存储此实例自身变量的字典

	__class__ 属性
		此属性用于绑定创建此实例的类

	作用:
		可以借助于此属性来访问创建此实例的类


用于类的函数:
	isinstance(obj,class_or_tuple)  返回这个对象obj是否是某个类的
	对象或某些类中的一个类的对象,如果是则返回True,否则返回False
	type(obj)  返回对象的类型



==============================================================================

类变量
	类变量是类的属性,此属性属于类,不属于此类的实例

	作用:
		通常用来存储该类创建的对象的共有属性

	说明:
		类变量可以通过该类直接访问
		类变量可以通过类的实例直接访问
		类变量可以通过此类的对象的 __class__ 属性间接访问


类的文档字符串
	类内第一个没有赋值给任何变量的字符串为类的文档字符串
	类的文档字符串可以用类的 __doc__ 属性访问


类的 __slots__ 列表
	作用:
		限定一个类创建的实例只能有固定的属性(实例变量)
		不允许对象添加列表以外的属性(实例变量)
		防止用户因错写属性的名称而发生程序错误
	
	说明:
		1.__slots__ 列表绑定一个字符串列表
		2.含有 __slots__ 列表的类所创建的实例对象没有 __dict__ 属性,
		  即此实例不用字典来存储对象的属性(实例变量)

类方法 @classmethod
	类方法是用于描述类的行为的方法,类方法属于类,不属于类的实例

	说明:
		类方法需要使用@classmethod装饰器定义
		类方法至少有一个形参,第一个形参用于绑定类,约定写为'cls'
		类和该类的实例都可以调用类方法
		类方法不能访问此类创建的实例的属性


静态方法 @staticmethod
	静态方法是定义在类内部的函数,此函数的作用域是类的内部

	说明:
		静态方法需要使用 @staticmethod 装饰器定义
		静态方法与普通函数定义相同,不需要传入self实例参数和cls参数
		静态方法只能凭借该类或类创建的实例调用
		静态方法不能访问类变量和实例变量(属性)



实例方法,类方法,静态方法,函数		小结
	不想访问 类内 和 实例内 的变量,用静态方法
	只想访问类内变量,不想访问实例变量,用类方法
	既要访问类变量,也想访问实例变量用实例方法
	函数与静态方法相同,只是静态方法的作用域定义在类内


继承  inheritance  /  派生  derived
	
	什么是继承/派生
		继承是指从已有的类中派生出新的类,新类具有原类的行为,并能扩展新的行为
		派生类就是从一个已有类中衍生成新类,在新类上可以添加新的属性和行为
	作用:
		1.用继承派生机制,可以将一些共有功能加在基类中,实现代码的共享
		2.在不改变基类的代码的基础上改变原有的功能
	名语:
		基类(base class) / 超类(super class) / 父类(father class)
		派生类(derived class) / 子类(child class)

单继承:
	语法:
		class 类名(基类名):
		    语句块
	说明:
		单继承是指由一个基类衍生出新的类
	
继承说明:
	python3任何类都是直接或间接的继承自object
	object类是一切类的超类

类的__base__属性
	__base__属性用来记录此类的基类

python内建的类详见:
	>>>help(__builtins__)

覆盖 override
	覆盖是指在有继承关系的类中,子类中实现了与基类同名的方法,在子类的实例
	调用该方法时,实际调用的是子类中的覆盖版本,这种现象叫做覆盖

子类对象显式调用基类(被覆盖)方法的方式:
	基类名.方法名(实例,实际调用传参)

super 函数
	super(cls, obj) 返回绑定超类的实例(要求obj必须是cls类型的实例)
	super() 返回绑定超类的实例,等同于: super(__class__, 实例方法的第一个参数),必须在方法内调用

	作用:
		借助super() 返回的实例间接调用其父类的覆盖方法

显式调用基类的初始化方法
	当子类中实现了 __init__ 方法,基类的构造方法并不会被调用
	def __init__(self,...)




=============================================================================================

 用于类的函数
	issubclass(cls, cls_or_tuple) 
	判断一个类是否继承自其它类,如果此cls 是class或tuple中的一个派生子类,则返回True,否则返回False


封装 enclosure
	封装是指隐藏类的实现细节,让使用者不关心这些细节
	封装的目的是让使用者通过尽可能少的方法(或属性)操作对象


私有属性和方法
	python类中以双下划线(__)开头,不以双下划线结尾的标识符为私有成员,私有成员或只能用类内的方法进行访问和修改
		以__开头的实例变量有私有属性
		以__开头的方法有私有方法
	

多态 polymorphic
	什么是多态:
		字面意思:多种状态
		多态是指在有继承/派生关系的类中,调用基类对象的方法,实际能调用子类的覆盖方法的现象叫多态

	状态:
		静态(编译时状态)
		动态(运行时状态)
	说明:
		多态调用方法与对象相关,不与类相关
		python的全部对象都只有"运行时状态(动态)",没有"c++语言"里的"编译时状态(静态)"


面向对象的语言的特征
	继承
	封装
	多态


多继承 multiple inheritance
	多继承是指一个子类继承自两个或两个以上的基类

	语法:
	class 类名(基类名1,基类名2,...):
	    ...
	说明:
		1.一个子类同时继承自多个父类,父类中的方法可以同时被继承下来
		2.如果两个父类中有同名的方法,而子类中又没有覆盖此方法时,调用结果难以确定


多继承的问题(缺陷)
	标识符(名字空间)冲突的问题
		要谨慎使用继承
	
多继承的 MRO (Method Resolution Order) 问题
	类的 __mro__ 属性
		此属性用来记录类的方法查找顺序


函数重写
	在自定义类内添加相应的方法,让自定义类创建的实例能像内建对象一样进行内建函数操作

对象转字符串函数:
	repr(obj)	返回一个能代表此对象的表达式字符串,通常
		eval(repr(obj)) == obj	(这个字符串通常是给python解释执行器运行用的)

	str(obj)	通过给定的对象返回一个字符串
			(这个字符串通常是给人阅读的)

对象转字符串函数的重写方法
	repr(obj)	函数的重写方法:
		def __repr__(self):
	
	str(obj)	函数的重写方法:
		def __str__(self):
		
		说明:
			1. str(obj) 函数先查找, obj.__str__()方法,调用此方法并返回
			2. 如果没有__str__()方法时,则返回obj.__repr__()方法的结果并返回
			3. 如果obj.__repr__方法不存在,则调用object类的__repr__实例方法显示
			   <__main__.XXXX object at 0xAABBCCDD>格式的字符串

其他内建函数的重写方法:
	__abs__		abs(obj)	函数
	__len__		len(obj)	函数(必须返回整数)
	__reversed__	reversed(obj)	函数(必须返回可迭代对象)
	__round__	round(obj)	函数

数值转换函数的重写
	__complex__	complex(obj)	函数
	__int__		int(obj)	函数
	__float__	float(obj)	函数
	__bool__	bool(obj)	函数

布尔测试函数重写
	格式:
		__bool__
	作用:
		用于bool(obj) 函数取值
		用于if语句的真值表达式中
		用于while 语句的真值表达式中
	说明:
		1.当自定义的类内有 __bool__(self)方法时,以此方法的返回值作为bool(obj)的返回值
		2.当不存在 __bool__(self) 方法时,bool(x)返回__len__(self)方法的返回值是否为零来测试布尔值
		3.当不存在__len__(self) 方法时,则直接返回True


迭代器(高级)
	什么是迭代器
		可以通过next(it)函数取值的对象就是迭代器
	
迭代器协议
	迭代器协议是指对象能够使用next函数获取下一项数据,在没有下一项数据是触发一个StopIteration异常来终止迭代的约写

	迭代器协议实现方法:
		__next__(self) 方法来实现迭代器协议

	语法形式:
		class MyIterator
		    def __next__(self):
		        迭代器协议
			return 数据

	什么是可迭代对象:
		是指能用iter(obj) 函数返回迭代器的对象(实例)
		可迭代对象内部需要定义__iter__(self) 方法来返回迭代器对象



=====================================================================================================================

对象的属性管理函数:
	getattr(obj, name[,default])
	从一个对象得到对象的属性;getattr(x,'y')等同于x.y,当属性不存在时,如果给出default参数则返回default
	如果没有给出default,则产生一个AttributeError错误hasattr(obj, name) 用给定的name返回对象obj是否有此属性,
	此种做法可以避免在getattr(obj, name)时引发错误
	settattr(obj, name, value)
	给对象obj的名为name的属性设置相应的值value;set(x,'y',z)等同于x.y=z
	delattr(obj,name)删除对象obj中的name属性,delattr(x,'y')等同于del x.y


异常(高级)
	可以用于异常的语句:
		try-except		# 捕获异常,得到异常通知
		try-finally		# 做任何流程(正常/异常 流程)都必须要执行的语句
		raise			# 发送异常通知
		assert			# 根据条件发送异常通知

		
with	语句
	语法:
		with 表达式1 [as 变量1], 表达式2 [as 变量2],...:
		    语句块
	作用:
		使用于对资源进行访问的场合,确保使用过程中不管是否发生异常都会执行
		必要的'清理操作',并释放资源
			(如:文件使用后自动关闭,线程中锁的自动获取和释放等)
	说明:
		执行表达式 as子句中的变量绑定生成的对象
		with语句并不改变异常的状态

环境管理器
	类内有__enter__ 和 __exit__ 实例方法的类被称为环境管理器
	能够用with进行管理的对象必须是环境管理器

	说明:
		__enter__将在进入with语句时被调用并返回由as变量绑定的对象
		__exit__将在离开with语句时被调用,且可以用参数来判断在离开with语句时是否有异常发生并做出相应的处理

	
运算符重载
	什么是运算符重载
		让自定义的类生成的对象(实例)能够使用运算符进行操作

	作用:
		1.让自定义的类实例能够运行运算符操作
		2.让程序简洁易读
		3.对自定义对象将运算符赋予新的运算规则

	说明:
		运算符重载方法的参数已经有固定的含义,不建议改变原有的意义

算术运算符重载
	方法名			运算符和表达式		说明
	__add__(slef,rhs)	self +  rhs		加法
	__sub__(slef,rhs)	self -  rhs		减法
	__mul__(slef,rhs)	self *  rhs		乘法
	__truediv__(slef,rhs)	self /  rhs		除法
	__floordiv__(slef,rhs)	self // rhs		地板除
	__mod__(slef,rhs)	self %  rhs		取模(求余)
	__pow__(slef,rhs)	self ** rhs		幂

	rhs(right hand side)	右手边


反向算术运算符的重载
	当运算符的左侧为内建类型,右侧为自定义类型的对象进行算术运算符运算时,会出现TypeError错误,
	因无法修改内建类的代码来实现运算符重载,此时需要使用反向算术运算符重载

反向算术运算符重载
	方法名			运算符和表达式		说明
	__radd__(slef,lhs)	lhs +  self		加法
	__rsub__(slef,lhs)	lhs -  self		减法
	__rmul__(slef,lhs)	lhs *  self		乘法
	__rtruediv__(slef,lhs)	lhs /  self		除法
	__rfloordiv__(slef,lhs)	lhs // self		地板除
	__rmod__(slef,lhs)	lhs %  self		取模(求余)
	__rpow__(slef,lhs)	lhs ** self		幂

	lhs(left hand side)	左手边

复合赋值算术运算符的重载
	以复合赋值算术运算符 x += y 为例,此运算会优先调用 x.__iadd__(y)方法,
	如果没有__iadd__方法时会将复合赋值运算符拆解为 x = x + y ,然后调用 x = x.__add__方法;
	如果不存在__add__方法则会触发TypeError异常

	其他复合赋值运算符也具有相同的规则

复合赋值算术运算符重载
	方法名			运算符和表达式		说明
	__iadd__(slef,rhs)	self +=  rhs		加法
	__isub__(slef,rhs)	self -=  rhs		减法
	__imul__(slef,rhs)	self *=  rhs		乘法
	__itruediv__(slef,rhs)	self /=  rhs		除法
	__ifloordiv__(slef,rhs)	self //= rhs		地板除
	__imod__(slef,rhs)	self %=  rhs		取模(求余)
	__ipow__(slef,rhs)	self **= rhs		幂


比较运算符的重载
	方法名			运算符和表达式		说明
	__lt__(self, rhs)	self <  rhs		小于
	__le__(self, rhs)	self <= rhs		小于等于
	__gt__(self, rhs)	self >  rhs		大于
	__ge__(self, rhs)	self >= rhs		大于等于
	__eq__(self, rhs)	self == rhs		等于
	__ne__(self, rhs)	self != rhs		不等于



重载方法:
	def __contains__(self,e)
	    ...

索引和切片运算符的重载
	

slice 函数
	作用:
		用于创建一个slice切片对象,此对象存储切片的信息


特性属性 @property
	实现其它语言所拥有的getter和setter的功能

	作用:
		用来模拟一个属性
		通过 @property 装饰器可以对模拟属性的取值和赋值加以控制



